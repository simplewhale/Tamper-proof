//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/alen/Downloads/signMessage-api/target/classes/core/org/spongycastle/util/encoders/HexEncoder.java
//

#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "java/io/IOException.h"
#include "java/io/OutputStream.h"
#include "org/spongycastle/util/encoders/HexEncoder.h"

@interface OrgSpongycastleUtilEncodersHexEncoder ()

+ (jboolean)ignoreWithChar:(jchar)c;

@end

__attribute__((unused)) static jboolean OrgSpongycastleUtilEncodersHexEncoder_ignoreWithChar_(jchar c);

@implementation OrgSpongycastleUtilEncodersHexEncoder

- (void)initialiseDecodingTable {
  for (jint i = 0; i < ((IOSByteArray *) nil_chk(decodingTable_))->size_; i++) {
    *IOSByteArray_GetRef(decodingTable_, i) = (jbyte) (jint) 0xff;
  }
  for (jint i = 0; i < ((IOSByteArray *) nil_chk(encodingTable_))->size_; i++) {
    *IOSByteArray_GetRef(decodingTable_, IOSByteArray_Get(encodingTable_, i)) = (jbyte) i;
  }
  *IOSByteArray_GetRef(decodingTable_, 'A') = IOSByteArray_Get(decodingTable_, 'a');
  *IOSByteArray_GetRef(decodingTable_, 'B') = IOSByteArray_Get(decodingTable_, 'b');
  *IOSByteArray_GetRef(decodingTable_, 'C') = IOSByteArray_Get(decodingTable_, 'c');
  *IOSByteArray_GetRef(decodingTable_, 'D') = IOSByteArray_Get(decodingTable_, 'd');
  *IOSByteArray_GetRef(decodingTable_, 'E') = IOSByteArray_Get(decodingTable_, 'e');
  *IOSByteArray_GetRef(decodingTable_, 'F') = IOSByteArray_Get(decodingTable_, 'f');
}

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  OrgSpongycastleUtilEncodersHexEncoder_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (jint)encodeWithByteArray:(IOSByteArray *)data
                    withInt:(jint)off
                    withInt:(jint)length
     withJavaIoOutputStream:(JavaIoOutputStream *)outArg {
  for (jint i = off; i < (off + length); i++) {
    jint v = IOSByteArray_Get(nil_chk(data), i) & (jint) 0xff;
    [((JavaIoOutputStream *) nil_chk(outArg)) writeWithInt:IOSByteArray_Get(nil_chk(encodingTable_), (JreURShift32(v, 4)))];
    [outArg writeWithInt:IOSByteArray_Get(encodingTable_, v & (jint) 0xf)];
  }
  return length * 2;
}

+ (jboolean)ignoreWithChar:(jchar)c {
  return OrgSpongycastleUtilEncodersHexEncoder_ignoreWithChar_(c);
}

- (jint)decodeWithByteArray:(IOSByteArray *)data
                    withInt:(jint)off
                    withInt:(jint)length
     withJavaIoOutputStream:(JavaIoOutputStream *)outArg {
  jbyte b1;
  jbyte b2;
  jint outLen = 0;
  jint end = off + length;
  while (end > off) {
    if (!OrgSpongycastleUtilEncodersHexEncoder_ignoreWithChar_((jchar) IOSByteArray_Get(nil_chk(data), end - 1))) {
      break;
    }
    end--;
  }
  jint i = off;
  while (i < end) {
    while (i < end && OrgSpongycastleUtilEncodersHexEncoder_ignoreWithChar_((jchar) IOSByteArray_Get(nil_chk(data), i))) {
      i++;
    }
    b1 = IOSByteArray_Get(nil_chk(decodingTable_), IOSByteArray_Get(nil_chk(data), i++));
    while (i < end && OrgSpongycastleUtilEncodersHexEncoder_ignoreWithChar_((jchar) IOSByteArray_Get(data, i))) {
      i++;
    }
    b2 = IOSByteArray_Get(decodingTable_, IOSByteArray_Get(data, i++));
    if ((b1 | b2) < 0) {
      @throw new_JavaIoIOException_initWithNSString_(@"invalid characters encountered in Hex data");
    }
    [((JavaIoOutputStream *) nil_chk(outArg)) writeWithInt:(JreLShift32(b1, 4)) | b2];
    outLen++;
  }
  return outLen;
}

- (jint)decodeWithNSString:(NSString *)data
    withJavaIoOutputStream:(JavaIoOutputStream *)outArg {
  jbyte b1;
  jbyte b2;
  jint length = 0;
  jint end = [((NSString *) nil_chk(data)) java_length];
  while (end > 0) {
    if (!OrgSpongycastleUtilEncodersHexEncoder_ignoreWithChar_([data charAtWithInt:end - 1])) {
      break;
    }
    end--;
  }
  jint i = 0;
  while (i < end) {
    while (i < end && OrgSpongycastleUtilEncodersHexEncoder_ignoreWithChar_([data charAtWithInt:i])) {
      i++;
    }
    b1 = IOSByteArray_Get(nil_chk(decodingTable_), [data charAtWithInt:i++]);
    while (i < end && OrgSpongycastleUtilEncodersHexEncoder_ignoreWithChar_([data charAtWithInt:i])) {
      i++;
    }
    b2 = IOSByteArray_Get(decodingTable_, [data charAtWithInt:i++]);
    if ((b1 | b2) < 0) {
      @throw new_JavaIoIOException_initWithNSString_(@"invalid characters encountered in Hex string");
    }
    [((JavaIoOutputStream *) nil_chk(outArg)) writeWithInt:(JreLShift32(b1, 4)) | b2];
    length++;
  }
  return length;
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "V", 0x4, -1, -1, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 0, 1, 2, -1, -1, -1 },
    { NULL, "Z", 0xa, 3, 4, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 5, 1, 2, -1, -1, -1 },
    { NULL, "I", 0x1, 5, 6, 2, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initialiseDecodingTable);
  methods[1].selector = @selector(init);
  methods[2].selector = @selector(encodeWithByteArray:withInt:withInt:withJavaIoOutputStream:);
  methods[3].selector = @selector(ignoreWithChar:);
  methods[4].selector = @selector(decodeWithByteArray:withInt:withInt:withJavaIoOutputStream:);
  methods[5].selector = @selector(decodeWithNSString:withJavaIoOutputStream:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "encodingTable_", "[B", .constantValue.asLong = 0, 0x14, -1, -1, -1, -1 },
    { "decodingTable_", "[B", .constantValue.asLong = 0, 0x14, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "encode", "[BIILJavaIoOutputStream;", "LJavaIoIOException;", "ignore", "C", "decode", "LNSString;LJavaIoOutputStream;" };
  static const J2ObjcClassInfo _OrgSpongycastleUtilEncodersHexEncoder = { "HexEncoder", "org.spongycastle.util.encoders", ptrTable, methods, fields, 7, 0x1, 6, 2, -1, -1, -1, -1, -1 };
  return &_OrgSpongycastleUtilEncodersHexEncoder;
}

@end

void OrgSpongycastleUtilEncodersHexEncoder_init(OrgSpongycastleUtilEncodersHexEncoder *self) {
  NSObject_init(self);
  self->encodingTable_ = [IOSByteArray newArrayWithBytes:(jbyte[]){ (jbyte) '0', (jbyte) '1', (jbyte) '2', (jbyte) '3', (jbyte) '4', (jbyte) '5', (jbyte) '6', (jbyte) '7', (jbyte) '8', (jbyte) '9', (jbyte) 'a', (jbyte) 'b', (jbyte) 'c', (jbyte) 'd', (jbyte) 'e', (jbyte) 'f' } count:16];
  self->decodingTable_ = [IOSByteArray newArrayWithLength:128];
  [self initialiseDecodingTable];
}

OrgSpongycastleUtilEncodersHexEncoder *new_OrgSpongycastleUtilEncodersHexEncoder_init() {
  J2OBJC_NEW_IMPL(OrgSpongycastleUtilEncodersHexEncoder, init)
}

OrgSpongycastleUtilEncodersHexEncoder *create_OrgSpongycastleUtilEncodersHexEncoder_init() {
  J2OBJC_CREATE_IMPL(OrgSpongycastleUtilEncodersHexEncoder, init)
}

jboolean OrgSpongycastleUtilEncodersHexEncoder_ignoreWithChar_(jchar c) {
  OrgSpongycastleUtilEncodersHexEncoder_initialize();
  return c == 0x000a || c == 0x000d || c == 0x0009 || c == ' ';
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(OrgSpongycastleUtilEncodersHexEncoder)
