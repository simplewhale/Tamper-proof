//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/alen/Downloads/signMessage-api/target/classes/core/org/spongycastle/crypto/macs/VMPCMac.java
//

#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/System.h"
#include "org/spongycastle/crypto/CipherParameters.h"
#include "org/spongycastle/crypto/DataLengthException.h"
#include "org/spongycastle/crypto/macs/VMPCMac.h"
#include "org/spongycastle/crypto/params/KeyParameter.h"
#include "org/spongycastle/crypto/params/ParametersWithIV.h"

@interface OrgSpongycastleCryptoMacsVMPCMac () {
 @public
  jbyte g_;
  jbyte n_;
  IOSByteArray *P_;
  jbyte s_;
  IOSByteArray *T_;
  IOSByteArray *workingIV_;
  IOSByteArray *workingKey_;
  jbyte x1_;
  jbyte x2_;
  jbyte x3_;
  jbyte x4_;
}

- (void)initKeyWithByteArray:(IOSByteArray *)keyBytes
               withByteArray:(IOSByteArray *)ivBytes OBJC_METHOD_FAMILY_NONE;

@end

J2OBJC_FIELD_SETTER(OrgSpongycastleCryptoMacsVMPCMac, P_, IOSByteArray *)
J2OBJC_FIELD_SETTER(OrgSpongycastleCryptoMacsVMPCMac, T_, IOSByteArray *)
J2OBJC_FIELD_SETTER(OrgSpongycastleCryptoMacsVMPCMac, workingIV_, IOSByteArray *)
J2OBJC_FIELD_SETTER(OrgSpongycastleCryptoMacsVMPCMac, workingKey_, IOSByteArray *)

__attribute__((unused)) static void OrgSpongycastleCryptoMacsVMPCMac_initKeyWithByteArray_withByteArray_(OrgSpongycastleCryptoMacsVMPCMac *self, IOSByteArray *keyBytes, IOSByteArray *ivBytes);

@implementation OrgSpongycastleCryptoMacsVMPCMac

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  OrgSpongycastleCryptoMacsVMPCMac_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (jint)doFinalWithByteArray:(IOSByteArray *)outArg
                     withInt:(jint)outOff {
  for (jint r = 1; r < 25; r++) {
    s_ = IOSByteArray_Get(P_, (s_ + IOSByteArray_Get(nil_chk(P_), n_ & (jint) 0xff)) & (jint) 0xff);
    x4_ = IOSByteArray_Get(P_, (x4_ + x3_ + r) & (jint) 0xff);
    x3_ = IOSByteArray_Get(P_, (x3_ + x2_ + r) & (jint) 0xff);
    x2_ = IOSByteArray_Get(P_, (x2_ + x1_ + r) & (jint) 0xff);
    x1_ = IOSByteArray_Get(P_, (x1_ + s_ + r) & (jint) 0xff);
    *IOSByteArray_GetRef(nil_chk(T_), g_ & (jint) 0x1f) = (jbyte) (IOSByteArray_Get(T_, g_ & (jint) 0x1f) ^ x1_);
    *IOSByteArray_GetRef(T_, (g_ + 1) & (jint) 0x1f) = (jbyte) (IOSByteArray_Get(T_, (g_ + 1) & (jint) 0x1f) ^ x2_);
    *IOSByteArray_GetRef(T_, (g_ + 2) & (jint) 0x1f) = (jbyte) (IOSByteArray_Get(T_, (g_ + 2) & (jint) 0x1f) ^ x3_);
    *IOSByteArray_GetRef(T_, (g_ + 3) & (jint) 0x1f) = (jbyte) (IOSByteArray_Get(T_, (g_ + 3) & (jint) 0x1f) ^ x4_);
    g_ = (jbyte) ((g_ + 4) & (jint) 0x1f);
    jbyte temp = IOSByteArray_Get(P_, n_ & (jint) 0xff);
    *IOSByteArray_GetRef(P_, n_ & (jint) 0xff) = IOSByteArray_Get(P_, s_ & (jint) 0xff);
    *IOSByteArray_GetRef(P_, s_ & (jint) 0xff) = temp;
    n_ = (jbyte) ((n_ + 1) & (jint) 0xff);
  }
  for (jint m = 0; m < 768; m++) {
    s_ = IOSByteArray_Get(P_, (s_ + IOSByteArray_Get(nil_chk(P_), m & (jint) 0xff) + IOSByteArray_Get(nil_chk(T_), m & (jint) 0x1f)) & (jint) 0xff);
    jbyte temp = IOSByteArray_Get(P_, m & (jint) 0xff);
    *IOSByteArray_GetRef(P_, m & (jint) 0xff) = IOSByteArray_Get(P_, s_ & (jint) 0xff);
    *IOSByteArray_GetRef(P_, s_ & (jint) 0xff) = temp;
  }
  IOSByteArray *M = [IOSByteArray newArrayWithLength:20];
  for (jint i = 0; i < 20; i++) {
    s_ = IOSByteArray_Get(P_, (s_ + IOSByteArray_Get(nil_chk(P_), i & (jint) 0xff)) & (jint) 0xff);
    *IOSByteArray_GetRef(M, i) = IOSByteArray_Get(P_, (IOSByteArray_Get(P_, (IOSByteArray_Get(P_, s_ & (jint) 0xff)) & (jint) 0xff) + 1) & (jint) 0xff);
    jbyte temp = IOSByteArray_Get(P_, i & (jint) 0xff);
    *IOSByteArray_GetRef(P_, i & (jint) 0xff) = IOSByteArray_Get(P_, s_ & (jint) 0xff);
    *IOSByteArray_GetRef(P_, s_ & (jint) 0xff) = temp;
  }
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(M, 0, outArg, outOff, M->size_);
  [self reset];
  return M->size_;
}

- (NSString *)getAlgorithmName {
  return @"VMPC-MAC";
}

- (jint)getMacSize {
  return 20;
}

- (void)init__WithOrgSpongycastleCryptoCipherParameters:(id<OrgSpongycastleCryptoCipherParameters>)params {
  if (!([params isKindOfClass:[OrgSpongycastleCryptoParamsParametersWithIV class]])) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"VMPC-MAC Init parameters must include an IV");
  }
  OrgSpongycastleCryptoParamsParametersWithIV *ivParams = (OrgSpongycastleCryptoParamsParametersWithIV *) cast_chk(params, [OrgSpongycastleCryptoParamsParametersWithIV class]);
  OrgSpongycastleCryptoParamsKeyParameter *key = (OrgSpongycastleCryptoParamsKeyParameter *) cast_chk([((OrgSpongycastleCryptoParamsParametersWithIV *) nil_chk(ivParams)) getParameters], [OrgSpongycastleCryptoParamsKeyParameter class]);
  if (!([[ivParams getParameters] isKindOfClass:[OrgSpongycastleCryptoParamsKeyParameter class]])) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"VMPC-MAC Init parameters must include a key");
  }
  self->workingIV_ = [ivParams getIV];
  if (workingIV_ == nil || workingIV_->size_ < 1 || workingIV_->size_ > 768) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"VMPC-MAC requires 1 to 768 bytes of IV");
  }
  self->workingKey_ = [((OrgSpongycastleCryptoParamsKeyParameter *) nil_chk(key)) getKey];
  [self reset];
}

- (void)initKeyWithByteArray:(IOSByteArray *)keyBytes
               withByteArray:(IOSByteArray *)ivBytes {
  OrgSpongycastleCryptoMacsVMPCMac_initKeyWithByteArray_withByteArray_(self, keyBytes, ivBytes);
}

- (void)reset {
  OrgSpongycastleCryptoMacsVMPCMac_initKeyWithByteArray_withByteArray_(self, self->workingKey_, self->workingIV_);
  g_ = x1_ = x2_ = x3_ = x4_ = n_ = 0;
  T_ = [IOSByteArray newArrayWithLength:32];
  for (jint i = 0; i < 32; i++) {
    *IOSByteArray_GetRef(T_, i) = 0;
  }
}

- (void)updateWithByte:(jbyte)inArg {
  s_ = IOSByteArray_Get(P_, (s_ + IOSByteArray_Get(nil_chk(P_), n_ & (jint) 0xff)) & (jint) 0xff);
  jbyte c = (jbyte) (inArg ^ IOSByteArray_Get(P_, (IOSByteArray_Get(P_, (IOSByteArray_Get(P_, s_ & (jint) 0xff)) & (jint) 0xff) + 1) & (jint) 0xff));
  x4_ = IOSByteArray_Get(P_, (x4_ + x3_) & (jint) 0xff);
  x3_ = IOSByteArray_Get(P_, (x3_ + x2_) & (jint) 0xff);
  x2_ = IOSByteArray_Get(P_, (x2_ + x1_) & (jint) 0xff);
  x1_ = IOSByteArray_Get(P_, (x1_ + s_ + c) & (jint) 0xff);
  *IOSByteArray_GetRef(nil_chk(T_), g_ & (jint) 0x1f) = (jbyte) (IOSByteArray_Get(T_, g_ & (jint) 0x1f) ^ x1_);
  *IOSByteArray_GetRef(T_, (g_ + 1) & (jint) 0x1f) = (jbyte) (IOSByteArray_Get(T_, (g_ + 1) & (jint) 0x1f) ^ x2_);
  *IOSByteArray_GetRef(T_, (g_ + 2) & (jint) 0x1f) = (jbyte) (IOSByteArray_Get(T_, (g_ + 2) & (jint) 0x1f) ^ x3_);
  *IOSByteArray_GetRef(T_, (g_ + 3) & (jint) 0x1f) = (jbyte) (IOSByteArray_Get(T_, (g_ + 3) & (jint) 0x1f) ^ x4_);
  g_ = (jbyte) ((g_ + 4) & (jint) 0x1f);
  jbyte temp = IOSByteArray_Get(P_, n_ & (jint) 0xff);
  *IOSByteArray_GetRef(P_, n_ & (jint) 0xff) = IOSByteArray_Get(P_, s_ & (jint) 0xff);
  *IOSByteArray_GetRef(P_, s_ & (jint) 0xff) = temp;
  n_ = (jbyte) ((n_ + 1) & (jint) 0xff);
}

- (void)updateWithByteArray:(IOSByteArray *)inArg
                    withInt:(jint)inOff
                    withInt:(jint)len {
  if ((inOff + len) > ((IOSByteArray *) nil_chk(inArg))->size_) {
    @throw new_OrgSpongycastleCryptoDataLengthException_initWithNSString_(@"input buffer too short");
  }
  for (jint i = 0; i < len; i++) {
    [self updateWithByte:IOSByteArray_Get(inArg, inOff + i)];
  }
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 0, 1, 2, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 3, 4, 5, -1, -1, -1 },
    { NULL, "V", 0x2, 6, 7, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 8, 9, 10, -1, -1, -1 },
    { NULL, "V", 0x1, 8, 11, 2, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(doFinalWithByteArray:withInt:);
  methods[2].selector = @selector(getAlgorithmName);
  methods[3].selector = @selector(getMacSize);
  methods[4].selector = @selector(init__WithOrgSpongycastleCryptoCipherParameters:);
  methods[5].selector = @selector(initKeyWithByteArray:withByteArray:);
  methods[6].selector = @selector(reset);
  methods[7].selector = @selector(updateWithByte:);
  methods[8].selector = @selector(updateWithByteArray:withInt:withInt:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "g_", "B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "n_", "B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "P_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "s_", "B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "T_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "workingIV_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "workingKey_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "x1_", "B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "x2_", "B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "x3_", "B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "x4_", "B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "doFinal", "[BI", "LOrgSpongycastleCryptoDataLengthException;LJavaLangIllegalStateException;", "init", "LOrgSpongycastleCryptoCipherParameters;", "LJavaLangIllegalArgumentException;", "initKey", "[B[B", "update", "B", "LJavaLangIllegalStateException;", "[BII" };
  static const J2ObjcClassInfo _OrgSpongycastleCryptoMacsVMPCMac = { "VMPCMac", "org.spongycastle.crypto.macs", ptrTable, methods, fields, 7, 0x1, 9, 11, -1, -1, -1, -1, -1 };
  return &_OrgSpongycastleCryptoMacsVMPCMac;
}

@end

void OrgSpongycastleCryptoMacsVMPCMac_init(OrgSpongycastleCryptoMacsVMPCMac *self) {
  NSObject_init(self);
  self->n_ = 0;
  self->P_ = nil;
  self->s_ = 0;
}

OrgSpongycastleCryptoMacsVMPCMac *new_OrgSpongycastleCryptoMacsVMPCMac_init() {
  J2OBJC_NEW_IMPL(OrgSpongycastleCryptoMacsVMPCMac, init)
}

OrgSpongycastleCryptoMacsVMPCMac *create_OrgSpongycastleCryptoMacsVMPCMac_init() {
  J2OBJC_CREATE_IMPL(OrgSpongycastleCryptoMacsVMPCMac, init)
}

void OrgSpongycastleCryptoMacsVMPCMac_initKeyWithByteArray_withByteArray_(OrgSpongycastleCryptoMacsVMPCMac *self, IOSByteArray *keyBytes, IOSByteArray *ivBytes) {
  self->s_ = 0;
  self->P_ = [IOSByteArray newArrayWithLength:256];
  for (jint i = 0; i < 256; i++) {
    *IOSByteArray_GetRef(self->P_, i) = (jbyte) i;
  }
  for (jint m = 0; m < 768; m++) {
    self->s_ = IOSByteArray_Get(self->P_, (self->s_ + IOSByteArray_Get(self->P_, m & (jint) 0xff) + IOSByteArray_Get(keyBytes, m % ((IOSByteArray *) nil_chk(keyBytes))->size_)) & (jint) 0xff);
    jbyte temp = IOSByteArray_Get(self->P_, m & (jint) 0xff);
    *IOSByteArray_GetRef(self->P_, m & (jint) 0xff) = IOSByteArray_Get(self->P_, self->s_ & (jint) 0xff);
    *IOSByteArray_GetRef(self->P_, self->s_ & (jint) 0xff) = temp;
  }
  for (jint m = 0; m < 768; m++) {
    self->s_ = IOSByteArray_Get(self->P_, (self->s_ + IOSByteArray_Get(self->P_, m & (jint) 0xff) + IOSByteArray_Get(ivBytes, m % ((IOSByteArray *) nil_chk(ivBytes))->size_)) & (jint) 0xff);
    jbyte temp = IOSByteArray_Get(self->P_, m & (jint) 0xff);
    *IOSByteArray_GetRef(self->P_, m & (jint) 0xff) = IOSByteArray_Get(self->P_, self->s_ & (jint) 0xff);
    *IOSByteArray_GetRef(self->P_, self->s_ & (jint) 0xff) = temp;
  }
  self->n_ = 0;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(OrgSpongycastleCryptoMacsVMPCMac)
