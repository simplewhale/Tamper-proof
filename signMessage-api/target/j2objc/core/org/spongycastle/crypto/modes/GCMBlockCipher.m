//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/alen/Downloads/signMessage-api/target/classes/core/org/spongycastle/crypto/modes/GCMBlockCipher.java
//

#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/Math.h"
#include "java/lang/System.h"
#include "org/spongycastle/crypto/BlockCipher.h"
#include "org/spongycastle/crypto/CipherParameters.h"
#include "org/spongycastle/crypto/DataLengthException.h"
#include "org/spongycastle/crypto/InvalidCipherTextException.h"
#include "org/spongycastle/crypto/OutputLengthException.h"
#include "org/spongycastle/crypto/modes/GCMBlockCipher.h"
#include "org/spongycastle/crypto/modes/gcm/GCMExponentiator.h"
#include "org/spongycastle/crypto/modes/gcm/GCMMultiplier.h"
#include "org/spongycastle/crypto/modes/gcm/GCMUtil.h"
#include "org/spongycastle/crypto/modes/gcm/Tables1kGCMExponentiator.h"
#include "org/spongycastle/crypto/modes/gcm/Tables8kGCMMultiplier.h"
#include "org/spongycastle/crypto/params/AEADParameters.h"
#include "org/spongycastle/crypto/params/KeyParameter.h"
#include "org/spongycastle/crypto/params/ParametersWithIV.h"
#include "org/spongycastle/util/Arrays.h"
#include "org/spongycastle/util/Pack.h"

@interface OrgSpongycastleCryptoModesGCMBlockCipher () {
 @public
  id<OrgSpongycastleCryptoBlockCipher> cipher_;
  id<OrgSpongycastleCryptoModesGcmGCMMultiplier> multiplier_;
  id<OrgSpongycastleCryptoModesGcmGCMExponentiator> exp_;
  jboolean forEncryption_;
  jboolean initialised_;
  jint macSize_;
  IOSByteArray *lastKey_;
  IOSByteArray *nonce_;
  IOSByteArray *initialAssociatedText_;
  IOSByteArray *H_;
  IOSByteArray *J0_;
  IOSByteArray *bufBlock_;
  IOSByteArray *macBlock_;
  IOSByteArray *S_;
  IOSByteArray *S_at_;
  IOSByteArray *S_atPre_;
  IOSByteArray *counter_;
  jint blocksRemaining_;
  jint bufOff_;
  jlong totalLength_;
  IOSByteArray *atBlock_;
  jint atBlockPos_;
  jlong atLength_;
  jlong atLengthPre_;
}

- (void)initCipher OBJC_METHOD_FAMILY_NONE;

- (void)outputBlockWithByteArray:(IOSByteArray *)output
                         withInt:(jint)offset;

- (void)resetWithBoolean:(jboolean)clearMac;

- (void)gCTRBlockWithByteArray:(IOSByteArray *)block
                 withByteArray:(IOSByteArray *)outArg
                       withInt:(jint)outOff;

- (void)gCTRPartialWithByteArray:(IOSByteArray *)buf
                         withInt:(jint)off
                         withInt:(jint)len
                   withByteArray:(IOSByteArray *)outArg
                         withInt:(jint)outOff;

- (void)gHASHWithByteArray:(IOSByteArray *)Y
             withByteArray:(IOSByteArray *)b
                   withInt:(jint)len;

- (void)gHASHBlockWithByteArray:(IOSByteArray *)Y
                  withByteArray:(IOSByteArray *)b;

- (void)gHASHPartialWithByteArray:(IOSByteArray *)Y
                    withByteArray:(IOSByteArray *)b
                          withInt:(jint)off
                          withInt:(jint)len;

- (IOSByteArray *)getNextCounterBlock;

- (void)checkStatus;

@end

J2OBJC_FIELD_SETTER(OrgSpongycastleCryptoModesGCMBlockCipher, cipher_, id<OrgSpongycastleCryptoBlockCipher>)
J2OBJC_FIELD_SETTER(OrgSpongycastleCryptoModesGCMBlockCipher, multiplier_, id<OrgSpongycastleCryptoModesGcmGCMMultiplier>)
J2OBJC_FIELD_SETTER(OrgSpongycastleCryptoModesGCMBlockCipher, exp_, id<OrgSpongycastleCryptoModesGcmGCMExponentiator>)
J2OBJC_FIELD_SETTER(OrgSpongycastleCryptoModesGCMBlockCipher, lastKey_, IOSByteArray *)
J2OBJC_FIELD_SETTER(OrgSpongycastleCryptoModesGCMBlockCipher, nonce_, IOSByteArray *)
J2OBJC_FIELD_SETTER(OrgSpongycastleCryptoModesGCMBlockCipher, initialAssociatedText_, IOSByteArray *)
J2OBJC_FIELD_SETTER(OrgSpongycastleCryptoModesGCMBlockCipher, H_, IOSByteArray *)
J2OBJC_FIELD_SETTER(OrgSpongycastleCryptoModesGCMBlockCipher, J0_, IOSByteArray *)
J2OBJC_FIELD_SETTER(OrgSpongycastleCryptoModesGCMBlockCipher, bufBlock_, IOSByteArray *)
J2OBJC_FIELD_SETTER(OrgSpongycastleCryptoModesGCMBlockCipher, macBlock_, IOSByteArray *)
J2OBJC_FIELD_SETTER(OrgSpongycastleCryptoModesGCMBlockCipher, S_, IOSByteArray *)
J2OBJC_FIELD_SETTER(OrgSpongycastleCryptoModesGCMBlockCipher, S_at_, IOSByteArray *)
J2OBJC_FIELD_SETTER(OrgSpongycastleCryptoModesGCMBlockCipher, S_atPre_, IOSByteArray *)
J2OBJC_FIELD_SETTER(OrgSpongycastleCryptoModesGCMBlockCipher, counter_, IOSByteArray *)
J2OBJC_FIELD_SETTER(OrgSpongycastleCryptoModesGCMBlockCipher, atBlock_, IOSByteArray *)

inline jint OrgSpongycastleCryptoModesGCMBlockCipher_get_BLOCK_SIZE(void);
#define OrgSpongycastleCryptoModesGCMBlockCipher_BLOCK_SIZE 16
J2OBJC_STATIC_FIELD_CONSTANT(OrgSpongycastleCryptoModesGCMBlockCipher, BLOCK_SIZE, jint)

__attribute__((unused)) static void OrgSpongycastleCryptoModesGCMBlockCipher_initCipher(OrgSpongycastleCryptoModesGCMBlockCipher *self);

__attribute__((unused)) static void OrgSpongycastleCryptoModesGCMBlockCipher_outputBlockWithByteArray_withInt_(OrgSpongycastleCryptoModesGCMBlockCipher *self, IOSByteArray *output, jint offset);

__attribute__((unused)) static void OrgSpongycastleCryptoModesGCMBlockCipher_resetWithBoolean_(OrgSpongycastleCryptoModesGCMBlockCipher *self, jboolean clearMac);

__attribute__((unused)) static void OrgSpongycastleCryptoModesGCMBlockCipher_gCTRBlockWithByteArray_withByteArray_withInt_(OrgSpongycastleCryptoModesGCMBlockCipher *self, IOSByteArray *block, IOSByteArray *outArg, jint outOff);

__attribute__((unused)) static void OrgSpongycastleCryptoModesGCMBlockCipher_gCTRPartialWithByteArray_withInt_withInt_withByteArray_withInt_(OrgSpongycastleCryptoModesGCMBlockCipher *self, IOSByteArray *buf, jint off, jint len, IOSByteArray *outArg, jint outOff);

__attribute__((unused)) static void OrgSpongycastleCryptoModesGCMBlockCipher_gHASHWithByteArray_withByteArray_withInt_(OrgSpongycastleCryptoModesGCMBlockCipher *self, IOSByteArray *Y, IOSByteArray *b, jint len);

__attribute__((unused)) static void OrgSpongycastleCryptoModesGCMBlockCipher_gHASHBlockWithByteArray_withByteArray_(OrgSpongycastleCryptoModesGCMBlockCipher *self, IOSByteArray *Y, IOSByteArray *b);

__attribute__((unused)) static void OrgSpongycastleCryptoModesGCMBlockCipher_gHASHPartialWithByteArray_withByteArray_withInt_withInt_(OrgSpongycastleCryptoModesGCMBlockCipher *self, IOSByteArray *Y, IOSByteArray *b, jint off, jint len);

__attribute__((unused)) static IOSByteArray *OrgSpongycastleCryptoModesGCMBlockCipher_getNextCounterBlock(OrgSpongycastleCryptoModesGCMBlockCipher *self);

__attribute__((unused)) static void OrgSpongycastleCryptoModesGCMBlockCipher_checkStatus(OrgSpongycastleCryptoModesGCMBlockCipher *self);

@implementation OrgSpongycastleCryptoModesGCMBlockCipher

- (instancetype)initWithOrgSpongycastleCryptoBlockCipher:(id<OrgSpongycastleCryptoBlockCipher>)c {
  OrgSpongycastleCryptoModesGCMBlockCipher_initWithOrgSpongycastleCryptoBlockCipher_(self, c);
  return self;
}

- (instancetype)initWithOrgSpongycastleCryptoBlockCipher:(id<OrgSpongycastleCryptoBlockCipher>)c
          withOrgSpongycastleCryptoModesGcmGCMMultiplier:(id<OrgSpongycastleCryptoModesGcmGCMMultiplier>)m {
  OrgSpongycastleCryptoModesGCMBlockCipher_initWithOrgSpongycastleCryptoBlockCipher_withOrgSpongycastleCryptoModesGcmGCMMultiplier_(self, c, m);
  return self;
}

- (id<OrgSpongycastleCryptoBlockCipher>)getUnderlyingCipher {
  return cipher_;
}

- (NSString *)getAlgorithmName {
  return JreStrcat("$$", [((id<OrgSpongycastleCryptoBlockCipher>) nil_chk(cipher_)) getAlgorithmName], @"/GCM");
}

- (void)init__WithBoolean:(jboolean)forEncryption
withOrgSpongycastleCryptoCipherParameters:(id<OrgSpongycastleCryptoCipherParameters>)params {
  self->forEncryption_ = forEncryption;
  self->macBlock_ = nil;
  self->initialised_ = true;
  OrgSpongycastleCryptoParamsKeyParameter *keyParam;
  IOSByteArray *newNonce = nil;
  if ([params isKindOfClass:[OrgSpongycastleCryptoParamsAEADParameters class]]) {
    OrgSpongycastleCryptoParamsAEADParameters *param = (OrgSpongycastleCryptoParamsAEADParameters *) params;
    newNonce = [((OrgSpongycastleCryptoParamsAEADParameters *) nil_chk(param)) getNonce];
    initialAssociatedText_ = [param getAssociatedText];
    jint macSizeBits = [param getMacSize];
    if (macSizeBits < 32 || macSizeBits > 128 || macSizeBits % 8 != 0) {
      @throw new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$I", @"Invalid value for MAC size: ", macSizeBits));
    }
    macSize_ = macSizeBits / 8;
    keyParam = [param getKey];
  }
  else if ([params isKindOfClass:[OrgSpongycastleCryptoParamsParametersWithIV class]]) {
    OrgSpongycastleCryptoParamsParametersWithIV *param = (OrgSpongycastleCryptoParamsParametersWithIV *) params;
    newNonce = [((OrgSpongycastleCryptoParamsParametersWithIV *) nil_chk(param)) getIV];
    initialAssociatedText_ = nil;
    macSize_ = 16;
    keyParam = (OrgSpongycastleCryptoParamsKeyParameter *) cast_chk([param getParameters], [OrgSpongycastleCryptoParamsKeyParameter class]);
  }
  else {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"invalid parameters passed to GCM");
  }
  jint bufLength = forEncryption ? OrgSpongycastleCryptoModesGCMBlockCipher_BLOCK_SIZE : (OrgSpongycastleCryptoModesGCMBlockCipher_BLOCK_SIZE + macSize_);
  self->bufBlock_ = [IOSByteArray newArrayWithLength:bufLength];
  if (newNonce == nil || newNonce->size_ < 1) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"IV must be at least 1 byte");
  }
  if (forEncryption) {
    if (nonce_ != nil && OrgSpongycastleUtilArrays_areEqualWithByteArray_withByteArray_(nonce_, newNonce)) {
      if (keyParam == nil) {
        @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"cannot reuse nonce for GCM encryption");
      }
      if (lastKey_ != nil && OrgSpongycastleUtilArrays_areEqualWithByteArray_withByteArray_(lastKey_, [keyParam getKey])) {
        @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"cannot reuse nonce for GCM encryption");
      }
    }
  }
  nonce_ = newNonce;
  if (keyParam != nil) {
    lastKey_ = [keyParam getKey];
  }
  if (keyParam != nil) {
    [((id<OrgSpongycastleCryptoBlockCipher>) nil_chk(cipher_)) init__WithBoolean:true withOrgSpongycastleCryptoCipherParameters:keyParam];
    self->H_ = [IOSByteArray newArrayWithLength:OrgSpongycastleCryptoModesGCMBlockCipher_BLOCK_SIZE];
    [((id<OrgSpongycastleCryptoBlockCipher>) nil_chk(cipher_)) processBlockWithByteArray:H_ withInt:0 withByteArray:H_ withInt:0];
    [((id<OrgSpongycastleCryptoModesGcmGCMMultiplier>) nil_chk(multiplier_)) init__WithByteArray:H_];
    exp_ = nil;
  }
  else if (self->H_ == nil) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"Key must be specified in initial init");
  }
  self->J0_ = [IOSByteArray newArrayWithLength:OrgSpongycastleCryptoModesGCMBlockCipher_BLOCK_SIZE];
  if (((IOSByteArray *) nil_chk(nonce_))->size_ == 12) {
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(nonce_, 0, J0_, 0, nonce_->size_);
    *IOSByteArray_GetRef(nil_chk(self->J0_), OrgSpongycastleCryptoModesGCMBlockCipher_BLOCK_SIZE - 1) = (jint) 0x01;
  }
  else {
    OrgSpongycastleCryptoModesGCMBlockCipher_gHASHWithByteArray_withByteArray_withInt_(self, J0_, nonce_, nonce_->size_);
    IOSByteArray *X = [IOSByteArray newArrayWithLength:OrgSpongycastleCryptoModesGCMBlockCipher_BLOCK_SIZE];
    OrgSpongycastleUtilPack_longToBigEndianWithLong_withByteArray_withInt_((jlong) ((IOSByteArray *) nil_chk(nonce_))->size_ * 8, X, 8);
    OrgSpongycastleCryptoModesGCMBlockCipher_gHASHBlockWithByteArray_withByteArray_(self, J0_, X);
  }
  self->S_ = [IOSByteArray newArrayWithLength:OrgSpongycastleCryptoModesGCMBlockCipher_BLOCK_SIZE];
  self->S_at_ = [IOSByteArray newArrayWithLength:OrgSpongycastleCryptoModesGCMBlockCipher_BLOCK_SIZE];
  self->S_atPre_ = [IOSByteArray newArrayWithLength:OrgSpongycastleCryptoModesGCMBlockCipher_BLOCK_SIZE];
  self->atBlock_ = [IOSByteArray newArrayWithLength:OrgSpongycastleCryptoModesGCMBlockCipher_BLOCK_SIZE];
  self->atBlockPos_ = 0;
  self->atLength_ = 0;
  self->atLengthPre_ = 0;
  self->counter_ = OrgSpongycastleUtilArrays_cloneWithByteArray_(J0_);
  self->blocksRemaining_ = -2;
  self->bufOff_ = 0;
  self->totalLength_ = 0;
  if (initialAssociatedText_ != nil) {
    [self processAADBytesWithByteArray:initialAssociatedText_ withInt:0 withInt:initialAssociatedText_->size_];
  }
}

- (IOSByteArray *)getMac {
  if (macBlock_ == nil) {
    return [IOSByteArray newArrayWithLength:macSize_];
  }
  return OrgSpongycastleUtilArrays_cloneWithByteArray_(macBlock_);
}

- (jint)getOutputSizeWithInt:(jint)len {
  jint totalData = len + bufOff_;
  if (forEncryption_) {
    return totalData + macSize_;
  }
  return totalData < macSize_ ? 0 : totalData - macSize_;
}

- (jint)getUpdateOutputSizeWithInt:(jint)len {
  jint totalData = len + bufOff_;
  if (!forEncryption_) {
    if (totalData < macSize_) {
      return 0;
    }
    totalData -= macSize_;
  }
  return totalData - totalData % OrgSpongycastleCryptoModesGCMBlockCipher_BLOCK_SIZE;
}

- (void)processAADByteWithByte:(jbyte)inArg {
  OrgSpongycastleCryptoModesGCMBlockCipher_checkStatus(self);
  *IOSByteArray_GetRef(nil_chk(atBlock_), atBlockPos_) = inArg;
  if (++atBlockPos_ == OrgSpongycastleCryptoModesGCMBlockCipher_BLOCK_SIZE) {
    OrgSpongycastleCryptoModesGCMBlockCipher_gHASHBlockWithByteArray_withByteArray_(self, S_at_, atBlock_);
    atBlockPos_ = 0;
    atLength_ += OrgSpongycastleCryptoModesGCMBlockCipher_BLOCK_SIZE;
  }
}

- (void)processAADBytesWithByteArray:(IOSByteArray *)inArg
                             withInt:(jint)inOff
                             withInt:(jint)len {
  OrgSpongycastleCryptoModesGCMBlockCipher_checkStatus(self);
  for (jint i = 0; i < len; ++i) {
    *IOSByteArray_GetRef(nil_chk(atBlock_), atBlockPos_) = IOSByteArray_Get(nil_chk(inArg), inOff + i);
    if (++atBlockPos_ == OrgSpongycastleCryptoModesGCMBlockCipher_BLOCK_SIZE) {
      OrgSpongycastleCryptoModesGCMBlockCipher_gHASHBlockWithByteArray_withByteArray_(self, S_at_, atBlock_);
      atBlockPos_ = 0;
      atLength_ += OrgSpongycastleCryptoModesGCMBlockCipher_BLOCK_SIZE;
    }
  }
}

- (void)initCipher {
  OrgSpongycastleCryptoModesGCMBlockCipher_initCipher(self);
}

- (jint)processByteWithByte:(jbyte)inArg
              withByteArray:(IOSByteArray *)outArg
                    withInt:(jint)outOff {
  OrgSpongycastleCryptoModesGCMBlockCipher_checkStatus(self);
  *IOSByteArray_GetRef(nil_chk(bufBlock_), bufOff_) = inArg;
  if (++bufOff_ == bufBlock_->size_) {
    OrgSpongycastleCryptoModesGCMBlockCipher_outputBlockWithByteArray_withInt_(self, outArg, outOff);
    return OrgSpongycastleCryptoModesGCMBlockCipher_BLOCK_SIZE;
  }
  return 0;
}

- (jint)processBytesWithByteArray:(IOSByteArray *)inArg
                          withInt:(jint)inOff
                          withInt:(jint)len
                    withByteArray:(IOSByteArray *)outArg
                          withInt:(jint)outOff {
  OrgSpongycastleCryptoModesGCMBlockCipher_checkStatus(self);
  if (((IOSByteArray *) nil_chk(inArg))->size_ < (inOff + len)) {
    @throw new_OrgSpongycastleCryptoDataLengthException_initWithNSString_(@"Input buffer too short");
  }
  jint resultLen = 0;
  for (jint i = 0; i < len; ++i) {
    *IOSByteArray_GetRef(nil_chk(bufBlock_), bufOff_) = IOSByteArray_Get(inArg, inOff + i);
    if (++bufOff_ == bufBlock_->size_) {
      OrgSpongycastleCryptoModesGCMBlockCipher_outputBlockWithByteArray_withInt_(self, outArg, outOff + resultLen);
      resultLen += OrgSpongycastleCryptoModesGCMBlockCipher_BLOCK_SIZE;
    }
  }
  return resultLen;
}

- (void)outputBlockWithByteArray:(IOSByteArray *)output
                         withInt:(jint)offset {
  OrgSpongycastleCryptoModesGCMBlockCipher_outputBlockWithByteArray_withInt_(self, output, offset);
}

- (jint)doFinalWithByteArray:(IOSByteArray *)outArg
                     withInt:(jint)outOff {
  OrgSpongycastleCryptoModesGCMBlockCipher_checkStatus(self);
  if (totalLength_ == 0) {
    OrgSpongycastleCryptoModesGCMBlockCipher_initCipher(self);
  }
  jint extra = bufOff_;
  if (forEncryption_) {
    if (((IOSByteArray *) nil_chk(outArg))->size_ < (outOff + extra + macSize_)) {
      @throw new_OrgSpongycastleCryptoOutputLengthException_initWithNSString_(@"Output buffer too short");
    }
  }
  else {
    if (extra < macSize_) {
      @throw new_OrgSpongycastleCryptoInvalidCipherTextException_initWithNSString_(@"data too short");
    }
    extra -= macSize_;
    if (((IOSByteArray *) nil_chk(outArg))->size_ < (outOff + extra)) {
      @throw new_OrgSpongycastleCryptoOutputLengthException_initWithNSString_(@"Output buffer too short");
    }
  }
  if (extra > 0) {
    OrgSpongycastleCryptoModesGCMBlockCipher_gCTRPartialWithByteArray_withInt_withInt_withByteArray_withInt_(self, bufBlock_, 0, extra, outArg, outOff);
  }
  atLength_ += atBlockPos_;
  if (atLength_ > atLengthPre_) {
    if (atBlockPos_ > 0) {
      OrgSpongycastleCryptoModesGCMBlockCipher_gHASHPartialWithByteArray_withByteArray_withInt_withInt_(self, S_at_, atBlock_, 0, atBlockPos_);
    }
    if (atLengthPre_ > 0) {
      OrgSpongycastleCryptoModesGcmGCMUtil_xor__WithByteArray_withByteArray_(S_at_, S_atPre_);
    }
    jlong c = JreURShift64(((totalLength_ * 8) + 127), 7);
    IOSByteArray *H_c = [IOSByteArray newArrayWithLength:16];
    if (exp_ == nil) {
      exp_ = new_OrgSpongycastleCryptoModesGcmTables1kGCMExponentiator_init();
      [exp_ init__WithByteArray:H_];
    }
    [((id<OrgSpongycastleCryptoModesGcmGCMExponentiator>) nil_chk(exp_)) exponentiateXWithLong:c withByteArray:H_c];
    OrgSpongycastleCryptoModesGcmGCMUtil_multiplyWithByteArray_withByteArray_(S_at_, H_c);
    OrgSpongycastleCryptoModesGcmGCMUtil_xor__WithByteArray_withByteArray_(S_, S_at_);
  }
  IOSByteArray *X = [IOSByteArray newArrayWithLength:OrgSpongycastleCryptoModesGCMBlockCipher_BLOCK_SIZE];
  OrgSpongycastleUtilPack_longToBigEndianWithLong_withByteArray_withInt_(atLength_ * 8, X, 0);
  OrgSpongycastleUtilPack_longToBigEndianWithLong_withByteArray_withInt_(totalLength_ * 8, X, 8);
  OrgSpongycastleCryptoModesGCMBlockCipher_gHASHBlockWithByteArray_withByteArray_(self, S_, X);
  IOSByteArray *tag = [IOSByteArray newArrayWithLength:OrgSpongycastleCryptoModesGCMBlockCipher_BLOCK_SIZE];
  [((id<OrgSpongycastleCryptoBlockCipher>) nil_chk(cipher_)) processBlockWithByteArray:J0_ withInt:0 withByteArray:tag withInt:0];
  OrgSpongycastleCryptoModesGcmGCMUtil_xor__WithByteArray_withByteArray_(tag, S_);
  jint resultLen = extra;
  self->macBlock_ = [IOSByteArray newArrayWithLength:macSize_];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(tag, 0, macBlock_, 0, macSize_);
  if (forEncryption_) {
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(macBlock_, 0, outArg, outOff + bufOff_, macSize_);
    resultLen += macSize_;
  }
  else {
    IOSByteArray *msgMac = [IOSByteArray newArrayWithLength:macSize_];
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(bufBlock_, extra, msgMac, 0, macSize_);
    if (!OrgSpongycastleUtilArrays_constantTimeAreEqualWithByteArray_withByteArray_(self->macBlock_, msgMac)) {
      @throw new_OrgSpongycastleCryptoInvalidCipherTextException_initWithNSString_(@"mac check in GCM failed");
    }
  }
  OrgSpongycastleCryptoModesGCMBlockCipher_resetWithBoolean_(self, false);
  return resultLen;
}

- (void)reset {
  OrgSpongycastleCryptoModesGCMBlockCipher_resetWithBoolean_(self, true);
}

- (void)resetWithBoolean:(jboolean)clearMac {
  OrgSpongycastleCryptoModesGCMBlockCipher_resetWithBoolean_(self, clearMac);
}

- (void)gCTRBlockWithByteArray:(IOSByteArray *)block
                 withByteArray:(IOSByteArray *)outArg
                       withInt:(jint)outOff {
  OrgSpongycastleCryptoModesGCMBlockCipher_gCTRBlockWithByteArray_withByteArray_withInt_(self, block, outArg, outOff);
}

- (void)gCTRPartialWithByteArray:(IOSByteArray *)buf
                         withInt:(jint)off
                         withInt:(jint)len
                   withByteArray:(IOSByteArray *)outArg
                         withInt:(jint)outOff {
  OrgSpongycastleCryptoModesGCMBlockCipher_gCTRPartialWithByteArray_withInt_withInt_withByteArray_withInt_(self, buf, off, len, outArg, outOff);
}

- (void)gHASHWithByteArray:(IOSByteArray *)Y
             withByteArray:(IOSByteArray *)b
                   withInt:(jint)len {
  OrgSpongycastleCryptoModesGCMBlockCipher_gHASHWithByteArray_withByteArray_withInt_(self, Y, b, len);
}

- (void)gHASHBlockWithByteArray:(IOSByteArray *)Y
                  withByteArray:(IOSByteArray *)b {
  OrgSpongycastleCryptoModesGCMBlockCipher_gHASHBlockWithByteArray_withByteArray_(self, Y, b);
}

- (void)gHASHPartialWithByteArray:(IOSByteArray *)Y
                    withByteArray:(IOSByteArray *)b
                          withInt:(jint)off
                          withInt:(jint)len {
  OrgSpongycastleCryptoModesGCMBlockCipher_gHASHPartialWithByteArray_withByteArray_withInt_withInt_(self, Y, b, off, len);
}

- (IOSByteArray *)getNextCounterBlock {
  return OrgSpongycastleCryptoModesGCMBlockCipher_getNextCounterBlock(self);
}

- (void)checkStatus {
  OrgSpongycastleCryptoModesGCMBlockCipher_checkStatus(self);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 1, -1, -1, -1, -1 },
    { NULL, "LOrgSpongycastleCryptoBlockCipher;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 2, 3, 4, -1, -1, -1 },
    { NULL, "[B", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 5, 6, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 7, 6, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 8, 9, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 10, 11, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 12, 13, 14, -1, -1, -1 },
    { NULL, "I", 0x1, 15, 16, 14, -1, -1, -1 },
    { NULL, "V", 0x2, 17, 18, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 19, 18, 20, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 21, 22, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 23, 24, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 25, 16, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 26, 24, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 27, 28, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 29, 30, -1, -1, -1, -1 },
    { NULL, "[B", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithOrgSpongycastleCryptoBlockCipher:);
  methods[1].selector = @selector(initWithOrgSpongycastleCryptoBlockCipher:withOrgSpongycastleCryptoModesGcmGCMMultiplier:);
  methods[2].selector = @selector(getUnderlyingCipher);
  methods[3].selector = @selector(getAlgorithmName);
  methods[4].selector = @selector(init__WithBoolean:withOrgSpongycastleCryptoCipherParameters:);
  methods[5].selector = @selector(getMac);
  methods[6].selector = @selector(getOutputSizeWithInt:);
  methods[7].selector = @selector(getUpdateOutputSizeWithInt:);
  methods[8].selector = @selector(processAADByteWithByte:);
  methods[9].selector = @selector(processAADBytesWithByteArray:withInt:withInt:);
  methods[10].selector = @selector(initCipher);
  methods[11].selector = @selector(processByteWithByte:withByteArray:withInt:);
  methods[12].selector = @selector(processBytesWithByteArray:withInt:withInt:withByteArray:withInt:);
  methods[13].selector = @selector(outputBlockWithByteArray:withInt:);
  methods[14].selector = @selector(doFinalWithByteArray:withInt:);
  methods[15].selector = @selector(reset);
  methods[16].selector = @selector(resetWithBoolean:);
  methods[17].selector = @selector(gCTRBlockWithByteArray:withByteArray:withInt:);
  methods[18].selector = @selector(gCTRPartialWithByteArray:withInt:withInt:withByteArray:withInt:);
  methods[19].selector = @selector(gHASHWithByteArray:withByteArray:withInt:);
  methods[20].selector = @selector(gHASHBlockWithByteArray:withByteArray:);
  methods[21].selector = @selector(gHASHPartialWithByteArray:withByteArray:withInt:withInt:);
  methods[22].selector = @selector(getNextCounterBlock);
  methods[23].selector = @selector(checkStatus);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "BLOCK_SIZE", "I", .constantValue.asInt = OrgSpongycastleCryptoModesGCMBlockCipher_BLOCK_SIZE, 0x1a, -1, -1, -1, -1 },
    { "cipher_", "LOrgSpongycastleCryptoBlockCipher;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "multiplier_", "LOrgSpongycastleCryptoModesGcmGCMMultiplier;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "exp_", "LOrgSpongycastleCryptoModesGcmGCMExponentiator;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "forEncryption_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "initialised_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "macSize_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "lastKey_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "nonce_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "initialAssociatedText_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "H_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "J0_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "bufBlock_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "macBlock_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "S_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "S_at_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "S_atPre_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "counter_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "blocksRemaining_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "bufOff_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "totalLength_", "J", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "atBlock_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "atBlockPos_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "atLength_", "J", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "atLengthPre_", "J", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LOrgSpongycastleCryptoBlockCipher;", "LOrgSpongycastleCryptoBlockCipher;LOrgSpongycastleCryptoModesGcmGCMMultiplier;", "init", "ZLOrgSpongycastleCryptoCipherParameters;", "LJavaLangIllegalArgumentException;", "getOutputSize", "I", "getUpdateOutputSize", "processAADByte", "B", "processAADBytes", "[BII", "processByte", "B[BI", "LOrgSpongycastleCryptoDataLengthException;", "processBytes", "[BII[BI", "outputBlock", "[BI", "doFinal", "LJavaLangIllegalStateException;LOrgSpongycastleCryptoInvalidCipherTextException;", "reset", "Z", "gCTRBlock", "[B[BI", "gCTRPartial", "gHASH", "gHASHBlock", "[B[B", "gHASHPartial", "[B[BII" };
  static const J2ObjcClassInfo _OrgSpongycastleCryptoModesGCMBlockCipher = { "GCMBlockCipher", "org.spongycastle.crypto.modes", ptrTable, methods, fields, 7, 0x1, 24, 25, -1, -1, -1, -1, -1 };
  return &_OrgSpongycastleCryptoModesGCMBlockCipher;
}

@end

void OrgSpongycastleCryptoModesGCMBlockCipher_initWithOrgSpongycastleCryptoBlockCipher_(OrgSpongycastleCryptoModesGCMBlockCipher *self, id<OrgSpongycastleCryptoBlockCipher> c) {
  OrgSpongycastleCryptoModesGCMBlockCipher_initWithOrgSpongycastleCryptoBlockCipher_withOrgSpongycastleCryptoModesGcmGCMMultiplier_(self, c, nil);
}

OrgSpongycastleCryptoModesGCMBlockCipher *new_OrgSpongycastleCryptoModesGCMBlockCipher_initWithOrgSpongycastleCryptoBlockCipher_(id<OrgSpongycastleCryptoBlockCipher> c) {
  J2OBJC_NEW_IMPL(OrgSpongycastleCryptoModesGCMBlockCipher, initWithOrgSpongycastleCryptoBlockCipher_, c)
}

OrgSpongycastleCryptoModesGCMBlockCipher *create_OrgSpongycastleCryptoModesGCMBlockCipher_initWithOrgSpongycastleCryptoBlockCipher_(id<OrgSpongycastleCryptoBlockCipher> c) {
  J2OBJC_CREATE_IMPL(OrgSpongycastleCryptoModesGCMBlockCipher, initWithOrgSpongycastleCryptoBlockCipher_, c)
}

void OrgSpongycastleCryptoModesGCMBlockCipher_initWithOrgSpongycastleCryptoBlockCipher_withOrgSpongycastleCryptoModesGcmGCMMultiplier_(OrgSpongycastleCryptoModesGCMBlockCipher *self, id<OrgSpongycastleCryptoBlockCipher> c, id<OrgSpongycastleCryptoModesGcmGCMMultiplier> m) {
  NSObject_init(self);
  if ([((id<OrgSpongycastleCryptoBlockCipher>) nil_chk(c)) getBlockSize] != OrgSpongycastleCryptoModesGCMBlockCipher_BLOCK_SIZE) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$IC", @"cipher required with a block size of ", OrgSpongycastleCryptoModesGCMBlockCipher_BLOCK_SIZE, '.'));
  }
  if (m == nil) {
    m = new_OrgSpongycastleCryptoModesGcmTables8kGCMMultiplier_init();
  }
  self->cipher_ = c;
  self->multiplier_ = m;
}

OrgSpongycastleCryptoModesGCMBlockCipher *new_OrgSpongycastleCryptoModesGCMBlockCipher_initWithOrgSpongycastleCryptoBlockCipher_withOrgSpongycastleCryptoModesGcmGCMMultiplier_(id<OrgSpongycastleCryptoBlockCipher> c, id<OrgSpongycastleCryptoModesGcmGCMMultiplier> m) {
  J2OBJC_NEW_IMPL(OrgSpongycastleCryptoModesGCMBlockCipher, initWithOrgSpongycastleCryptoBlockCipher_withOrgSpongycastleCryptoModesGcmGCMMultiplier_, c, m)
}

OrgSpongycastleCryptoModesGCMBlockCipher *create_OrgSpongycastleCryptoModesGCMBlockCipher_initWithOrgSpongycastleCryptoBlockCipher_withOrgSpongycastleCryptoModesGcmGCMMultiplier_(id<OrgSpongycastleCryptoBlockCipher> c, id<OrgSpongycastleCryptoModesGcmGCMMultiplier> m) {
  J2OBJC_CREATE_IMPL(OrgSpongycastleCryptoModesGCMBlockCipher, initWithOrgSpongycastleCryptoBlockCipher_withOrgSpongycastleCryptoModesGcmGCMMultiplier_, c, m)
}

void OrgSpongycastleCryptoModesGCMBlockCipher_initCipher(OrgSpongycastleCryptoModesGCMBlockCipher *self) {
  if (self->atLength_ > 0) {
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(self->S_at_, 0, self->S_atPre_, 0, OrgSpongycastleCryptoModesGCMBlockCipher_BLOCK_SIZE);
    self->atLengthPre_ = self->atLength_;
  }
  if (self->atBlockPos_ > 0) {
    OrgSpongycastleCryptoModesGCMBlockCipher_gHASHPartialWithByteArray_withByteArray_withInt_withInt_(self, self->S_atPre_, self->atBlock_, 0, self->atBlockPos_);
    self->atLengthPre_ += self->atBlockPos_;
  }
  if (self->atLengthPre_ > 0) {
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(self->S_atPre_, 0, self->S_, 0, OrgSpongycastleCryptoModesGCMBlockCipher_BLOCK_SIZE);
  }
}

void OrgSpongycastleCryptoModesGCMBlockCipher_outputBlockWithByteArray_withInt_(OrgSpongycastleCryptoModesGCMBlockCipher *self, IOSByteArray *output, jint offset) {
  if (((IOSByteArray *) nil_chk(output))->size_ < (offset + OrgSpongycastleCryptoModesGCMBlockCipher_BLOCK_SIZE)) {
    @throw new_OrgSpongycastleCryptoOutputLengthException_initWithNSString_(@"Output buffer too short");
  }
  if (self->totalLength_ == 0) {
    OrgSpongycastleCryptoModesGCMBlockCipher_initCipher(self);
  }
  OrgSpongycastleCryptoModesGCMBlockCipher_gCTRBlockWithByteArray_withByteArray_withInt_(self, self->bufBlock_, output, offset);
  if (self->forEncryption_) {
    self->bufOff_ = 0;
  }
  else {
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(self->bufBlock_, OrgSpongycastleCryptoModesGCMBlockCipher_BLOCK_SIZE, self->bufBlock_, 0, self->macSize_);
    self->bufOff_ = self->macSize_;
  }
}

void OrgSpongycastleCryptoModesGCMBlockCipher_resetWithBoolean_(OrgSpongycastleCryptoModesGCMBlockCipher *self, jboolean clearMac) {
  [((id<OrgSpongycastleCryptoBlockCipher>) nil_chk(self->cipher_)) reset];
  self->S_ = [IOSByteArray newArrayWithLength:OrgSpongycastleCryptoModesGCMBlockCipher_BLOCK_SIZE];
  self->S_at_ = [IOSByteArray newArrayWithLength:OrgSpongycastleCryptoModesGCMBlockCipher_BLOCK_SIZE];
  self->S_atPre_ = [IOSByteArray newArrayWithLength:OrgSpongycastleCryptoModesGCMBlockCipher_BLOCK_SIZE];
  self->atBlock_ = [IOSByteArray newArrayWithLength:OrgSpongycastleCryptoModesGCMBlockCipher_BLOCK_SIZE];
  self->atBlockPos_ = 0;
  self->atLength_ = 0;
  self->atLengthPre_ = 0;
  self->counter_ = OrgSpongycastleUtilArrays_cloneWithByteArray_(self->J0_);
  self->blocksRemaining_ = -2;
  self->bufOff_ = 0;
  self->totalLength_ = 0;
  if (self->bufBlock_ != nil) {
    OrgSpongycastleUtilArrays_fillWithByteArray_withByte_(self->bufBlock_, (jbyte) 0);
  }
  if (clearMac) {
    self->macBlock_ = nil;
  }
  if (self->forEncryption_) {
    self->initialised_ = false;
  }
  else {
    if (self->initialAssociatedText_ != nil) {
      [self processAADBytesWithByteArray:self->initialAssociatedText_ withInt:0 withInt:self->initialAssociatedText_->size_];
    }
  }
}

void OrgSpongycastleCryptoModesGCMBlockCipher_gCTRBlockWithByteArray_withByteArray_withInt_(OrgSpongycastleCryptoModesGCMBlockCipher *self, IOSByteArray *block, IOSByteArray *outArg, jint outOff) {
  IOSByteArray *tmp = OrgSpongycastleCryptoModesGCMBlockCipher_getNextCounterBlock(self);
  OrgSpongycastleCryptoModesGcmGCMUtil_xor__WithByteArray_withByteArray_(tmp, block);
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(tmp, 0, outArg, outOff, OrgSpongycastleCryptoModesGCMBlockCipher_BLOCK_SIZE);
  OrgSpongycastleCryptoModesGCMBlockCipher_gHASHBlockWithByteArray_withByteArray_(self, self->S_, self->forEncryption_ ? tmp : block);
  self->totalLength_ += OrgSpongycastleCryptoModesGCMBlockCipher_BLOCK_SIZE;
}

void OrgSpongycastleCryptoModesGCMBlockCipher_gCTRPartialWithByteArray_withInt_withInt_withByteArray_withInt_(OrgSpongycastleCryptoModesGCMBlockCipher *self, IOSByteArray *buf, jint off, jint len, IOSByteArray *outArg, jint outOff) {
  IOSByteArray *tmp = OrgSpongycastleCryptoModesGCMBlockCipher_getNextCounterBlock(self);
  OrgSpongycastleCryptoModesGcmGCMUtil_xor__WithByteArray_withByteArray_withInt_withInt_(tmp, buf, off, len);
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(tmp, 0, outArg, outOff, len);
  OrgSpongycastleCryptoModesGCMBlockCipher_gHASHPartialWithByteArray_withByteArray_withInt_withInt_(self, self->S_, self->forEncryption_ ? tmp : buf, 0, len);
  self->totalLength_ += len;
}

void OrgSpongycastleCryptoModesGCMBlockCipher_gHASHWithByteArray_withByteArray_withInt_(OrgSpongycastleCryptoModesGCMBlockCipher *self, IOSByteArray *Y, IOSByteArray *b, jint len) {
  for (jint pos = 0; pos < len; pos += OrgSpongycastleCryptoModesGCMBlockCipher_BLOCK_SIZE) {
    jint num = JavaLangMath_minWithInt_withInt_(len - pos, OrgSpongycastleCryptoModesGCMBlockCipher_BLOCK_SIZE);
    OrgSpongycastleCryptoModesGCMBlockCipher_gHASHPartialWithByteArray_withByteArray_withInt_withInt_(self, Y, b, pos, num);
  }
}

void OrgSpongycastleCryptoModesGCMBlockCipher_gHASHBlockWithByteArray_withByteArray_(OrgSpongycastleCryptoModesGCMBlockCipher *self, IOSByteArray *Y, IOSByteArray *b) {
  OrgSpongycastleCryptoModesGcmGCMUtil_xor__WithByteArray_withByteArray_(Y, b);
  [((id<OrgSpongycastleCryptoModesGcmGCMMultiplier>) nil_chk(self->multiplier_)) multiplyHWithByteArray:Y];
}

void OrgSpongycastleCryptoModesGCMBlockCipher_gHASHPartialWithByteArray_withByteArray_withInt_withInt_(OrgSpongycastleCryptoModesGCMBlockCipher *self, IOSByteArray *Y, IOSByteArray *b, jint off, jint len) {
  OrgSpongycastleCryptoModesGcmGCMUtil_xor__WithByteArray_withByteArray_withInt_withInt_(Y, b, off, len);
  [((id<OrgSpongycastleCryptoModesGcmGCMMultiplier>) nil_chk(self->multiplier_)) multiplyHWithByteArray:Y];
}

IOSByteArray *OrgSpongycastleCryptoModesGCMBlockCipher_getNextCounterBlock(OrgSpongycastleCryptoModesGCMBlockCipher *self) {
  if (self->blocksRemaining_ == 0) {
    @throw new_JavaLangIllegalStateException_initWithNSString_(@"Attempt to process too many blocks");
  }
  self->blocksRemaining_--;
  jint c = 1;
  c += IOSByteArray_Get(nil_chk(self->counter_), 15) & (jint) 0xFF;
  *IOSByteArray_GetRef(self->counter_, 15) = (jbyte) c;
  JreURShiftAssignInt(&c, 8);
  c += IOSByteArray_Get(self->counter_, 14) & (jint) 0xFF;
  *IOSByteArray_GetRef(self->counter_, 14) = (jbyte) c;
  JreURShiftAssignInt(&c, 8);
  c += IOSByteArray_Get(self->counter_, 13) & (jint) 0xFF;
  *IOSByteArray_GetRef(self->counter_, 13) = (jbyte) c;
  JreURShiftAssignInt(&c, 8);
  c += IOSByteArray_Get(self->counter_, 12) & (jint) 0xFF;
  *IOSByteArray_GetRef(self->counter_, 12) = (jbyte) c;
  IOSByteArray *tmp = [IOSByteArray newArrayWithLength:OrgSpongycastleCryptoModesGCMBlockCipher_BLOCK_SIZE];
  [((id<OrgSpongycastleCryptoBlockCipher>) nil_chk(self->cipher_)) processBlockWithByteArray:self->counter_ withInt:0 withByteArray:tmp withInt:0];
  return tmp;
}

void OrgSpongycastleCryptoModesGCMBlockCipher_checkStatus(OrgSpongycastleCryptoModesGCMBlockCipher *self) {
  if (!self->initialised_) {
    if (self->forEncryption_) {
      @throw new_JavaLangIllegalStateException_initWithNSString_(@"GCM cipher cannot be reused for encryption");
    }
    @throw new_JavaLangIllegalStateException_initWithNSString_(@"GCM cipher needs to be initialised");
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(OrgSpongycastleCryptoModesGCMBlockCipher)
