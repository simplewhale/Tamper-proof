//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/alen/Downloads/signMessage-api/target/classes/core/org/spongycastle/crypto/modes/KCCMBlockCipher.java
//

#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "java/io/ByteArrayOutputStream.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/Integer.h"
#include "java/lang/StringBuffer.h"
#include "java/lang/System.h"
#include "org/spongycastle/crypto/BlockCipher.h"
#include "org/spongycastle/crypto/CipherParameters.h"
#include "org/spongycastle/crypto/DataLengthException.h"
#include "org/spongycastle/crypto/InvalidCipherTextException.h"
#include "org/spongycastle/crypto/OutputLengthException.h"
#include "org/spongycastle/crypto/modes/KCCMBlockCipher.h"
#include "org/spongycastle/crypto/params/AEADParameters.h"
#include "org/spongycastle/crypto/params/KeyParameter.h"
#include "org/spongycastle/crypto/params/ParametersWithIV.h"
#include "org/spongycastle/util/Arrays.h"

@class OrgSpongycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream;

@interface OrgSpongycastleCryptoModesKCCMBlockCipher () {
 @public
  id<OrgSpongycastleCryptoBlockCipher> engine_;
  jint macSize_;
  jboolean forEncryption_;
  IOSByteArray *initialAssociatedText_;
  IOSByteArray *mac_;
  IOSByteArray *macBlock_;
  IOSByteArray *nonce_;
  IOSByteArray *G1_;
  IOSByteArray *buffer_;
  IOSByteArray *s_;
  IOSByteArray *counter_;
  OrgSpongycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream *associatedText_;
  OrgSpongycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream *data_;
  jint Nb__;
}

- (void)setNbWithInt:(jint)Nb;

- (void)processAADWithByteArray:(IOSByteArray *)assocText
                        withInt:(jint)assocOff
                        withInt:(jint)assocLen
                        withInt:(jint)dataLen;

- (void)ProcessBlockWithByteArray:(IOSByteArray *)input
                          withInt:(jint)inOff
                          withInt:(jint)len
                    withByteArray:(IOSByteArray *)output
                          withInt:(jint)outOff;

- (void)CalculateMacWithByteArray:(IOSByteArray *)authText
                          withInt:(jint)authOff
                          withInt:(jint)len;

- (void)intToBytesWithInt:(jint)num
            withByteArray:(IOSByteArray *)outBytes
                  withInt:(jint)outOff;

- (jbyte)getFlagWithBoolean:(jboolean)authTextPresents
                    withInt:(jint)macSize;

@end

J2OBJC_FIELD_SETTER(OrgSpongycastleCryptoModesKCCMBlockCipher, engine_, id<OrgSpongycastleCryptoBlockCipher>)
J2OBJC_FIELD_SETTER(OrgSpongycastleCryptoModesKCCMBlockCipher, initialAssociatedText_, IOSByteArray *)
J2OBJC_FIELD_SETTER(OrgSpongycastleCryptoModesKCCMBlockCipher, mac_, IOSByteArray *)
J2OBJC_FIELD_SETTER(OrgSpongycastleCryptoModesKCCMBlockCipher, macBlock_, IOSByteArray *)
J2OBJC_FIELD_SETTER(OrgSpongycastleCryptoModesKCCMBlockCipher, nonce_, IOSByteArray *)
J2OBJC_FIELD_SETTER(OrgSpongycastleCryptoModesKCCMBlockCipher, G1_, IOSByteArray *)
J2OBJC_FIELD_SETTER(OrgSpongycastleCryptoModesKCCMBlockCipher, buffer_, IOSByteArray *)
J2OBJC_FIELD_SETTER(OrgSpongycastleCryptoModesKCCMBlockCipher, s_, IOSByteArray *)
J2OBJC_FIELD_SETTER(OrgSpongycastleCryptoModesKCCMBlockCipher, counter_, IOSByteArray *)
J2OBJC_FIELD_SETTER(OrgSpongycastleCryptoModesKCCMBlockCipher, associatedText_, OrgSpongycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream *)
J2OBJC_FIELD_SETTER(OrgSpongycastleCryptoModesKCCMBlockCipher, data_, OrgSpongycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream *)

inline jint OrgSpongycastleCryptoModesKCCMBlockCipher_get_BYTES_IN_INT(void);
#define OrgSpongycastleCryptoModesKCCMBlockCipher_BYTES_IN_INT 4
J2OBJC_STATIC_FIELD_CONSTANT(OrgSpongycastleCryptoModesKCCMBlockCipher, BYTES_IN_INT, jint)

inline jint OrgSpongycastleCryptoModesKCCMBlockCipher_get_BITS_IN_BYTE(void);
#define OrgSpongycastleCryptoModesKCCMBlockCipher_BITS_IN_BYTE 8
J2OBJC_STATIC_FIELD_CONSTANT(OrgSpongycastleCryptoModesKCCMBlockCipher, BITS_IN_BYTE, jint)

inline jint OrgSpongycastleCryptoModesKCCMBlockCipher_get_MAX_MAC_BIT_LENGTH(void);
#define OrgSpongycastleCryptoModesKCCMBlockCipher_MAX_MAC_BIT_LENGTH 512
J2OBJC_STATIC_FIELD_CONSTANT(OrgSpongycastleCryptoModesKCCMBlockCipher, MAX_MAC_BIT_LENGTH, jint)

inline jint OrgSpongycastleCryptoModesKCCMBlockCipher_get_MIN_MAC_BIT_LENGTH(void);
#define OrgSpongycastleCryptoModesKCCMBlockCipher_MIN_MAC_BIT_LENGTH 64
J2OBJC_STATIC_FIELD_CONSTANT(OrgSpongycastleCryptoModesKCCMBlockCipher, MIN_MAC_BIT_LENGTH, jint)

__attribute__((unused)) static void OrgSpongycastleCryptoModesKCCMBlockCipher_setNbWithInt_(OrgSpongycastleCryptoModesKCCMBlockCipher *self, jint Nb);

__attribute__((unused)) static void OrgSpongycastleCryptoModesKCCMBlockCipher_processAADWithByteArray_withInt_withInt_withInt_(OrgSpongycastleCryptoModesKCCMBlockCipher *self, IOSByteArray *assocText, jint assocOff, jint assocLen, jint dataLen);

__attribute__((unused)) static void OrgSpongycastleCryptoModesKCCMBlockCipher_ProcessBlockWithByteArray_withInt_withInt_withByteArray_withInt_(OrgSpongycastleCryptoModesKCCMBlockCipher *self, IOSByteArray *input, jint inOff, jint len, IOSByteArray *output, jint outOff);

__attribute__((unused)) static void OrgSpongycastleCryptoModesKCCMBlockCipher_CalculateMacWithByteArray_withInt_withInt_(OrgSpongycastleCryptoModesKCCMBlockCipher *self, IOSByteArray *authText, jint authOff, jint len);

__attribute__((unused)) static void OrgSpongycastleCryptoModesKCCMBlockCipher_intToBytesWithInt_withByteArray_withInt_(OrgSpongycastleCryptoModesKCCMBlockCipher *self, jint num, IOSByteArray *outBytes, jint outOff);

__attribute__((unused)) static jbyte OrgSpongycastleCryptoModesKCCMBlockCipher_getFlagWithBoolean_withInt_(OrgSpongycastleCryptoModesKCCMBlockCipher *self, jboolean authTextPresents, jint macSize);

@interface OrgSpongycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream : JavaIoByteArrayOutputStream

- (instancetype)initWithOrgSpongycastleCryptoModesKCCMBlockCipher:(OrgSpongycastleCryptoModesKCCMBlockCipher *)outer$;

- (IOSByteArray *)getBuffer;

@end

J2OBJC_EMPTY_STATIC_INIT(OrgSpongycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream)

__attribute__((unused)) static void OrgSpongycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream_initWithOrgSpongycastleCryptoModesKCCMBlockCipher_(OrgSpongycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream *self, OrgSpongycastleCryptoModesKCCMBlockCipher *outer$);

__attribute__((unused)) static OrgSpongycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream *new_OrgSpongycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream_initWithOrgSpongycastleCryptoModesKCCMBlockCipher_(OrgSpongycastleCryptoModesKCCMBlockCipher *outer$) NS_RETURNS_RETAINED;

__attribute__((unused)) static OrgSpongycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream *create_OrgSpongycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream_initWithOrgSpongycastleCryptoModesKCCMBlockCipher_(OrgSpongycastleCryptoModesKCCMBlockCipher *outer$);

J2OBJC_TYPE_LITERAL_HEADER(OrgSpongycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream)

@implementation OrgSpongycastleCryptoModesKCCMBlockCipher

- (void)setNbWithInt:(jint)Nb {
  OrgSpongycastleCryptoModesKCCMBlockCipher_setNbWithInt_(self, Nb);
}

- (instancetype)initWithOrgSpongycastleCryptoBlockCipher:(id<OrgSpongycastleCryptoBlockCipher>)engine {
  OrgSpongycastleCryptoModesKCCMBlockCipher_initWithOrgSpongycastleCryptoBlockCipher_(self, engine);
  return self;
}

- (instancetype)initWithOrgSpongycastleCryptoBlockCipher:(id<OrgSpongycastleCryptoBlockCipher>)engine
                                                 withInt:(jint)nB {
  OrgSpongycastleCryptoModesKCCMBlockCipher_initWithOrgSpongycastleCryptoBlockCipher_withInt_(self, engine, nB);
  return self;
}

- (void)init__WithBoolean:(jboolean)forEncryption
withOrgSpongycastleCryptoCipherParameters:(id<OrgSpongycastleCryptoCipherParameters>)params {
  id<OrgSpongycastleCryptoCipherParameters> cipherParameters;
  if ([params isKindOfClass:[OrgSpongycastleCryptoParamsAEADParameters class]]) {
    OrgSpongycastleCryptoParamsAEADParameters *parameters = (OrgSpongycastleCryptoParamsAEADParameters *) params;
    if ([((OrgSpongycastleCryptoParamsAEADParameters *) nil_chk(parameters)) getMacSize] > OrgSpongycastleCryptoModesKCCMBlockCipher_MAX_MAC_BIT_LENGTH || [parameters getMacSize] < OrgSpongycastleCryptoModesKCCMBlockCipher_MIN_MAC_BIT_LENGTH || [parameters getMacSize] % 8 != 0) {
      @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"Invalid mac size specified");
    }
    nonce_ = [parameters getNonce];
    macSize_ = [parameters getMacSize] / OrgSpongycastleCryptoModesKCCMBlockCipher_BITS_IN_BYTE;
    initialAssociatedText_ = [parameters getAssociatedText];
    cipherParameters = [parameters getKey];
  }
  else if ([params isKindOfClass:[OrgSpongycastleCryptoParamsParametersWithIV class]]) {
    nonce_ = [((OrgSpongycastleCryptoParamsParametersWithIV *) nil_chk(((OrgSpongycastleCryptoParamsParametersWithIV *) params))) getIV];
    macSize_ = [((id<OrgSpongycastleCryptoBlockCipher>) nil_chk(engine_)) getBlockSize];
    initialAssociatedText_ = nil;
    cipherParameters = [((OrgSpongycastleCryptoParamsParametersWithIV *) nil_chk(((OrgSpongycastleCryptoParamsParametersWithIV *) params))) getParameters];
  }
  else {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"Invalid parameters specified");
  }
  self->mac_ = [IOSByteArray newArrayWithLength:macSize_];
  self->forEncryption_ = forEncryption;
  [((id<OrgSpongycastleCryptoBlockCipher>) nil_chk(engine_)) init__WithBoolean:true withOrgSpongycastleCryptoCipherParameters:cipherParameters];
  *IOSByteArray_GetRef(nil_chk(counter_), 0) = (jint) 0x01;
  if (initialAssociatedText_ != nil) {
    [self processAADBytesWithByteArray:initialAssociatedText_ withInt:0 withInt:initialAssociatedText_->size_];
  }
}

- (NSString *)getAlgorithmName {
  return JreStrcat("$$", [((id<OrgSpongycastleCryptoBlockCipher>) nil_chk(engine_)) getAlgorithmName], @"/KCCM");
}

- (id<OrgSpongycastleCryptoBlockCipher>)getUnderlyingCipher {
  return engine_;
}

- (void)processAADByteWithByte:(jbyte)inArg {
  [((OrgSpongycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(associatedText_)) writeWithInt:inArg];
}

- (void)processAADBytesWithByteArray:(IOSByteArray *)inArg
                             withInt:(jint)inOff
                             withInt:(jint)len {
  [((OrgSpongycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(associatedText_)) writeWithByteArray:inArg withInt:inOff withInt:len];
}

- (void)processAADWithByteArray:(IOSByteArray *)assocText
                        withInt:(jint)assocOff
                        withInt:(jint)assocLen
                        withInt:(jint)dataLen {
  OrgSpongycastleCryptoModesKCCMBlockCipher_processAADWithByteArray_withInt_withInt_withInt_(self, assocText, assocOff, assocLen, dataLen);
}

- (jint)processByteWithByte:(jbyte)inArg
              withByteArray:(IOSByteArray *)outArg
                    withInt:(jint)outOff {
  [((OrgSpongycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(data_)) writeWithInt:inArg];
  return 0;
}

- (jint)processBytesWithByteArray:(IOSByteArray *)inArg
                          withInt:(jint)inOff
                          withInt:(jint)inLen
                    withByteArray:(IOSByteArray *)outArg
                          withInt:(jint)outOff {
  if (((IOSByteArray *) nil_chk(inArg))->size_ < (inOff + inLen)) {
    @throw new_OrgSpongycastleCryptoDataLengthException_initWithNSString_(@"input buffer too short");
  }
  [((OrgSpongycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(data_)) writeWithByteArray:inArg withInt:inOff withInt:inLen];
  return 0;
}

- (jint)processPacketWithByteArray:(IOSByteArray *)inArg
                           withInt:(jint)inOff
                           withInt:(jint)len
                     withByteArray:(IOSByteArray *)outArg
                           withInt:(jint)outOff {
  if (((IOSByteArray *) nil_chk(inArg))->size_ - inOff < len) {
    @throw new_OrgSpongycastleCryptoDataLengthException_initWithNSString_(@"input buffer too short");
  }
  if (((IOSByteArray *) nil_chk(outArg))->size_ - outOff < len) {
    @throw new_OrgSpongycastleCryptoOutputLengthException_initWithNSString_(@"output buffer too short");
  }
  if ([((OrgSpongycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(associatedText_)) size] > 0) {
    if (forEncryption_) {
      OrgSpongycastleCryptoModesKCCMBlockCipher_processAADWithByteArray_withInt_withInt_withInt_(self, [((OrgSpongycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(associatedText_)) getBuffer], 0, [((OrgSpongycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(associatedText_)) size], [((OrgSpongycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(data_)) size]);
    }
    else {
      OrgSpongycastleCryptoModesKCCMBlockCipher_processAADWithByteArray_withInt_withInt_withInt_(self, [((OrgSpongycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(associatedText_)) getBuffer], 0, [((OrgSpongycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(associatedText_)) size], [((OrgSpongycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(data_)) size] - macSize_);
    }
  }
  if (forEncryption_) {
    if ((len % [((id<OrgSpongycastleCryptoBlockCipher>) nil_chk(engine_)) getBlockSize]) != 0) {
      @throw new_OrgSpongycastleCryptoDataLengthException_initWithNSString_(@"partial blocks not supported");
    }
    OrgSpongycastleCryptoModesKCCMBlockCipher_CalculateMacWithByteArray_withInt_withInt_(self, inArg, inOff, len);
    [((id<OrgSpongycastleCryptoBlockCipher>) nil_chk(engine_)) processBlockWithByteArray:nonce_ withInt:0 withByteArray:s_ withInt:0];
    jint totalLength = len;
    while (totalLength > 0) {
      OrgSpongycastleCryptoModesKCCMBlockCipher_ProcessBlockWithByteArray_withInt_withInt_withByteArray_withInt_(self, inArg, inOff, len, outArg, outOff);
      totalLength -= [((id<OrgSpongycastleCryptoBlockCipher>) nil_chk(engine_)) getBlockSize];
      inOff += [((id<OrgSpongycastleCryptoBlockCipher>) nil_chk(engine_)) getBlockSize];
      outOff += [((id<OrgSpongycastleCryptoBlockCipher>) nil_chk(engine_)) getBlockSize];
    }
    for (jint byteIndex = 0; byteIndex < ((IOSByteArray *) nil_chk(counter_))->size_; byteIndex++) {
      *IOSByteArray_GetRef(nil_chk(s_), byteIndex) += IOSByteArray_Get(counter_, byteIndex);
    }
    [((id<OrgSpongycastleCryptoBlockCipher>) nil_chk(engine_)) processBlockWithByteArray:s_ withInt:0 withByteArray:buffer_ withInt:0];
    for (jint byteIndex = 0; byteIndex < macSize_; byteIndex++) {
      *IOSByteArray_GetRef(outArg, outOff + byteIndex) = (jbyte) (IOSByteArray_Get(nil_chk(buffer_), byteIndex) ^ IOSByteArray_Get(nil_chk(macBlock_), byteIndex));
    }
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(macBlock_, 0, mac_, 0, macSize_);
    [self reset];
    return len + macSize_;
  }
  else {
    if ((len - macSize_) % [((id<OrgSpongycastleCryptoBlockCipher>) nil_chk(engine_)) getBlockSize] != 0) {
      @throw new_OrgSpongycastleCryptoDataLengthException_initWithNSString_(@"partial blocks not supported");
    }
    [((id<OrgSpongycastleCryptoBlockCipher>) nil_chk(engine_)) processBlockWithByteArray:nonce_ withInt:0 withByteArray:s_ withInt:0];
    jint blocks = len / [((id<OrgSpongycastleCryptoBlockCipher>) nil_chk(engine_)) getBlockSize];
    for (jint blockNum = 0; blockNum < blocks; blockNum++) {
      OrgSpongycastleCryptoModesKCCMBlockCipher_ProcessBlockWithByteArray_withInt_withInt_withByteArray_withInt_(self, inArg, inOff, len, outArg, outOff);
      inOff += [((id<OrgSpongycastleCryptoBlockCipher>) nil_chk(engine_)) getBlockSize];
      outOff += [((id<OrgSpongycastleCryptoBlockCipher>) nil_chk(engine_)) getBlockSize];
    }
    if (len > inOff) {
      for (jint byteIndex = 0; byteIndex < ((IOSByteArray *) nil_chk(counter_))->size_; byteIndex++) {
        *IOSByteArray_GetRef(nil_chk(s_), byteIndex) += IOSByteArray_Get(counter_, byteIndex);
      }
      [((id<OrgSpongycastleCryptoBlockCipher>) nil_chk(engine_)) processBlockWithByteArray:s_ withInt:0 withByteArray:buffer_ withInt:0];
      for (jint byteIndex = 0; byteIndex < macSize_; byteIndex++) {
        *IOSByteArray_GetRef(outArg, outOff + byteIndex) = (jbyte) (IOSByteArray_Get(nil_chk(buffer_), byteIndex) ^ IOSByteArray_Get(inArg, inOff + byteIndex));
      }
      outOff += macSize_;
    }
    for (jint byteIndex = 0; byteIndex < ((IOSByteArray *) nil_chk(counter_))->size_; byteIndex++) {
      *IOSByteArray_GetRef(nil_chk(s_), byteIndex) += IOSByteArray_Get(counter_, byteIndex);
    }
    [((id<OrgSpongycastleCryptoBlockCipher>) nil_chk(engine_)) processBlockWithByteArray:s_ withInt:0 withByteArray:buffer_ withInt:0];
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(outArg, outOff - macSize_, buffer_, 0, macSize_);
    OrgSpongycastleCryptoModesKCCMBlockCipher_CalculateMacWithByteArray_withInt_withInt_(self, outArg, 0, outOff - macSize_);
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(macBlock_, 0, mac_, 0, macSize_);
    IOSByteArray *calculatedMac = [IOSByteArray newArrayWithLength:macSize_];
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(buffer_, 0, calculatedMac, 0, macSize_);
    if (!OrgSpongycastleUtilArrays_constantTimeAreEqualWithByteArray_withByteArray_(mac_, calculatedMac)) {
      @throw new_OrgSpongycastleCryptoInvalidCipherTextException_initWithNSString_(@"mac check failed");
    }
    [self reset];
    return len - macSize_;
  }
}

- (void)ProcessBlockWithByteArray:(IOSByteArray *)input
                          withInt:(jint)inOff
                          withInt:(jint)len
                    withByteArray:(IOSByteArray *)output
                          withInt:(jint)outOff {
  OrgSpongycastleCryptoModesKCCMBlockCipher_ProcessBlockWithByteArray_withInt_withInt_withByteArray_withInt_(self, input, inOff, len, output, outOff);
}

- (void)CalculateMacWithByteArray:(IOSByteArray *)authText
                          withInt:(jint)authOff
                          withInt:(jint)len {
  OrgSpongycastleCryptoModesKCCMBlockCipher_CalculateMacWithByteArray_withInt_withInt_(self, authText, authOff, len);
}

- (jint)doFinalWithByteArray:(IOSByteArray *)outArg
                     withInt:(jint)outOff {
  jint len = [self processPacketWithByteArray:[((OrgSpongycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(data_)) getBuffer] withInt:0 withInt:[((OrgSpongycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(data_)) size] withByteArray:outArg withInt:outOff];
  [self reset];
  return len;
}

- (IOSByteArray *)getMac {
  return OrgSpongycastleUtilArrays_cloneWithByteArray_(mac_);
}

- (jint)getUpdateOutputSizeWithInt:(jint)len {
  return len;
}

- (jint)getOutputSizeWithInt:(jint)len {
  return len + macSize_;
}

- (void)reset {
  OrgSpongycastleUtilArrays_fillWithByteArray_withByte_(G1_, (jbyte) 0);
  OrgSpongycastleUtilArrays_fillWithByteArray_withByte_(buffer_, (jbyte) 0);
  OrgSpongycastleUtilArrays_fillWithByteArray_withByte_(counter_, (jbyte) 0);
  OrgSpongycastleUtilArrays_fillWithByteArray_withByte_(macBlock_, (jbyte) 0);
  *IOSByteArray_GetRef(nil_chk(counter_), 0) = (jint) 0x01;
  [((OrgSpongycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(data_)) reset];
  [((OrgSpongycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(associatedText_)) reset];
  if (initialAssociatedText_ != nil) {
    [self processAADBytesWithByteArray:initialAssociatedText_ withInt:0 withInt:initialAssociatedText_->size_];
  }
}

- (void)intToBytesWithInt:(jint)num
            withByteArray:(IOSByteArray *)outBytes
                  withInt:(jint)outOff {
  OrgSpongycastleCryptoModesKCCMBlockCipher_intToBytesWithInt_withByteArray_withInt_(self, num, outBytes, outOff);
}

- (jbyte)getFlagWithBoolean:(jboolean)authTextPresents
                    withInt:(jint)macSize {
  return OrgSpongycastleCryptoModesKCCMBlockCipher_getFlagWithBoolean_withInt_(self, authTextPresents, macSize);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "V", 0x2, 0, 1, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 2, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 3, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 4, 5, 6, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LOrgSpongycastleCryptoBlockCipher;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 7, 8, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 9, 10, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 11, 12, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 13, 14, 15, -1, -1, -1 },
    { NULL, "I", 0x1, 16, 17, 15, -1, -1, -1 },
    { NULL, "I", 0x1, 18, 17, 19, -1, -1, -1 },
    { NULL, "V", 0x2, 20, 17, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 21, 10, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 22, 23, 19, -1, -1, -1 },
    { NULL, "[B", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 24, 1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 25, 1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 26, 27, -1, -1, -1, -1 },
    { NULL, "B", 0x2, 28, 29, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(setNbWithInt:);
  methods[1].selector = @selector(initWithOrgSpongycastleCryptoBlockCipher:);
  methods[2].selector = @selector(initWithOrgSpongycastleCryptoBlockCipher:withInt:);
  methods[3].selector = @selector(init__WithBoolean:withOrgSpongycastleCryptoCipherParameters:);
  methods[4].selector = @selector(getAlgorithmName);
  methods[5].selector = @selector(getUnderlyingCipher);
  methods[6].selector = @selector(processAADByteWithByte:);
  methods[7].selector = @selector(processAADBytesWithByteArray:withInt:withInt:);
  methods[8].selector = @selector(processAADWithByteArray:withInt:withInt:withInt:);
  methods[9].selector = @selector(processByteWithByte:withByteArray:withInt:);
  methods[10].selector = @selector(processBytesWithByteArray:withInt:withInt:withByteArray:withInt:);
  methods[11].selector = @selector(processPacketWithByteArray:withInt:withInt:withByteArray:withInt:);
  methods[12].selector = @selector(ProcessBlockWithByteArray:withInt:withInt:withByteArray:withInt:);
  methods[13].selector = @selector(CalculateMacWithByteArray:withInt:withInt:);
  methods[14].selector = @selector(doFinalWithByteArray:withInt:);
  methods[15].selector = @selector(getMac);
  methods[16].selector = @selector(getUpdateOutputSizeWithInt:);
  methods[17].selector = @selector(getOutputSizeWithInt:);
  methods[18].selector = @selector(reset);
  methods[19].selector = @selector(intToBytesWithInt:withByteArray:withInt:);
  methods[20].selector = @selector(getFlagWithBoolean:withInt:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "BYTES_IN_INT", "I", .constantValue.asInt = OrgSpongycastleCryptoModesKCCMBlockCipher_BYTES_IN_INT, 0x1a, -1, -1, -1, -1 },
    { "BITS_IN_BYTE", "I", .constantValue.asInt = OrgSpongycastleCryptoModesKCCMBlockCipher_BITS_IN_BYTE, 0x1a, -1, -1, -1, -1 },
    { "MAX_MAC_BIT_LENGTH", "I", .constantValue.asInt = OrgSpongycastleCryptoModesKCCMBlockCipher_MAX_MAC_BIT_LENGTH, 0x1a, -1, -1, -1, -1 },
    { "MIN_MAC_BIT_LENGTH", "I", .constantValue.asInt = OrgSpongycastleCryptoModesKCCMBlockCipher_MIN_MAC_BIT_LENGTH, 0x1a, -1, -1, -1, -1 },
    { "engine_", "LOrgSpongycastleCryptoBlockCipher;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "macSize_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "forEncryption_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "initialAssociatedText_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mac_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "macBlock_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "nonce_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "G1_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "buffer_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "s_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "counter_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "associatedText_", "LOrgSpongycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "data_", "LOrgSpongycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "Nb__", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "setNb", "I", "LOrgSpongycastleCryptoBlockCipher;", "LOrgSpongycastleCryptoBlockCipher;I", "init", "ZLOrgSpongycastleCryptoCipherParameters;", "LJavaLangIllegalArgumentException;", "processAADByte", "B", "processAADBytes", "[BII", "processAAD", "[BIII", "processByte", "B[BI", "LOrgSpongycastleCryptoDataLengthException;LJavaLangIllegalStateException;", "processBytes", "[BII[BI", "processPacket", "LJavaLangIllegalStateException;LOrgSpongycastleCryptoInvalidCipherTextException;", "ProcessBlock", "CalculateMac", "doFinal", "[BI", "getUpdateOutputSize", "getOutputSize", "intToBytes", "I[BI", "getFlag", "ZI", "LOrgSpongycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream;" };
  static const J2ObjcClassInfo _OrgSpongycastleCryptoModesKCCMBlockCipher = { "KCCMBlockCipher", "org.spongycastle.crypto.modes", ptrTable, methods, fields, 7, 0x1, 21, 18, -1, 30, -1, -1, -1 };
  return &_OrgSpongycastleCryptoModesKCCMBlockCipher;
}

@end

void OrgSpongycastleCryptoModesKCCMBlockCipher_setNbWithInt_(OrgSpongycastleCryptoModesKCCMBlockCipher *self, jint Nb) {
  if (Nb == 4 || Nb == 6 || Nb == 8) {
    self->Nb__ = Nb;
  }
  else {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"Nb = 4 is recommended by DSTU7624 but can be changed to only 6 or 8 in this implementation");
  }
}

void OrgSpongycastleCryptoModesKCCMBlockCipher_initWithOrgSpongycastleCryptoBlockCipher_(OrgSpongycastleCryptoModesKCCMBlockCipher *self, id<OrgSpongycastleCryptoBlockCipher> engine) {
  OrgSpongycastleCryptoModesKCCMBlockCipher_initWithOrgSpongycastleCryptoBlockCipher_withInt_(self, engine, 4);
}

OrgSpongycastleCryptoModesKCCMBlockCipher *new_OrgSpongycastleCryptoModesKCCMBlockCipher_initWithOrgSpongycastleCryptoBlockCipher_(id<OrgSpongycastleCryptoBlockCipher> engine) {
  J2OBJC_NEW_IMPL(OrgSpongycastleCryptoModesKCCMBlockCipher, initWithOrgSpongycastleCryptoBlockCipher_, engine)
}

OrgSpongycastleCryptoModesKCCMBlockCipher *create_OrgSpongycastleCryptoModesKCCMBlockCipher_initWithOrgSpongycastleCryptoBlockCipher_(id<OrgSpongycastleCryptoBlockCipher> engine) {
  J2OBJC_CREATE_IMPL(OrgSpongycastleCryptoModesKCCMBlockCipher, initWithOrgSpongycastleCryptoBlockCipher_, engine)
}

void OrgSpongycastleCryptoModesKCCMBlockCipher_initWithOrgSpongycastleCryptoBlockCipher_withInt_(OrgSpongycastleCryptoModesKCCMBlockCipher *self, id<OrgSpongycastleCryptoBlockCipher> engine, jint nB) {
  NSObject_init(self);
  self->associatedText_ = new_OrgSpongycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream_initWithOrgSpongycastleCryptoModesKCCMBlockCipher_(self);
  self->data_ = new_OrgSpongycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream_initWithOrgSpongycastleCryptoModesKCCMBlockCipher_(self);
  self->Nb__ = 4;
  self->engine_ = engine;
  self->macSize_ = [((id<OrgSpongycastleCryptoBlockCipher>) nil_chk(engine)) getBlockSize];
  self->nonce_ = [IOSByteArray newArrayWithLength:[engine getBlockSize]];
  self->initialAssociatedText_ = [IOSByteArray newArrayWithLength:[engine getBlockSize]];
  self->mac_ = [IOSByteArray newArrayWithLength:[engine getBlockSize]];
  self->macBlock_ = [IOSByteArray newArrayWithLength:[engine getBlockSize]];
  self->G1_ = [IOSByteArray newArrayWithLength:[engine getBlockSize]];
  self->buffer_ = [IOSByteArray newArrayWithLength:[engine getBlockSize]];
  self->s_ = [IOSByteArray newArrayWithLength:[engine getBlockSize]];
  self->counter_ = [IOSByteArray newArrayWithLength:[engine getBlockSize]];
  OrgSpongycastleCryptoModesKCCMBlockCipher_setNbWithInt_(self, nB);
}

OrgSpongycastleCryptoModesKCCMBlockCipher *new_OrgSpongycastleCryptoModesKCCMBlockCipher_initWithOrgSpongycastleCryptoBlockCipher_withInt_(id<OrgSpongycastleCryptoBlockCipher> engine, jint nB) {
  J2OBJC_NEW_IMPL(OrgSpongycastleCryptoModesKCCMBlockCipher, initWithOrgSpongycastleCryptoBlockCipher_withInt_, engine, nB)
}

OrgSpongycastleCryptoModesKCCMBlockCipher *create_OrgSpongycastleCryptoModesKCCMBlockCipher_initWithOrgSpongycastleCryptoBlockCipher_withInt_(id<OrgSpongycastleCryptoBlockCipher> engine, jint nB) {
  J2OBJC_CREATE_IMPL(OrgSpongycastleCryptoModesKCCMBlockCipher, initWithOrgSpongycastleCryptoBlockCipher_withInt_, engine, nB)
}

void OrgSpongycastleCryptoModesKCCMBlockCipher_processAADWithByteArray_withInt_withInt_withInt_(OrgSpongycastleCryptoModesKCCMBlockCipher *self, IOSByteArray *assocText, jint assocOff, jint assocLen, jint dataLen) {
  if (assocLen - assocOff < [((id<OrgSpongycastleCryptoBlockCipher>) nil_chk(self->engine_)) getBlockSize]) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"authText buffer too short");
  }
  if (assocLen % [((id<OrgSpongycastleCryptoBlockCipher>) nil_chk(self->engine_)) getBlockSize] != 0) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"padding not supported");
  }
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(self->nonce_, 0, self->G1_, 0, ((IOSByteArray *) nil_chk(self->nonce_))->size_ - self->Nb__ - 1);
  OrgSpongycastleCryptoModesKCCMBlockCipher_intToBytesWithInt_withByteArray_withInt_(self, dataLen, self->buffer_, 0);
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(self->buffer_, 0, self->G1_, ((IOSByteArray *) nil_chk(self->nonce_))->size_ - self->Nb__ - 1, OrgSpongycastleCryptoModesKCCMBlockCipher_BYTES_IN_INT);
  *IOSByteArray_GetRef(self->G1_, ((IOSByteArray *) nil_chk(self->G1_))->size_ - 1) = OrgSpongycastleCryptoModesKCCMBlockCipher_getFlagWithBoolean_withInt_(self, true, self->macSize_);
  [((id<OrgSpongycastleCryptoBlockCipher>) nil_chk(self->engine_)) processBlockWithByteArray:self->G1_ withInt:0 withByteArray:self->macBlock_ withInt:0];
  OrgSpongycastleCryptoModesKCCMBlockCipher_intToBytesWithInt_withByteArray_withInt_(self, assocLen, self->buffer_, 0);
  if (assocLen <= [((id<OrgSpongycastleCryptoBlockCipher>) nil_chk(self->engine_)) getBlockSize] - self->Nb__) {
    for (jint byteIndex = 0; byteIndex < assocLen; byteIndex++) {
      *IOSByteArray_GetRef(nil_chk(self->buffer_), byteIndex + self->Nb__) ^= IOSByteArray_Get(nil_chk(assocText), assocOff + byteIndex);
    }
    for (jint byteIndex = 0; byteIndex < [((id<OrgSpongycastleCryptoBlockCipher>) nil_chk(self->engine_)) getBlockSize]; byteIndex++) {
      *IOSByteArray_GetRef(nil_chk(self->macBlock_), byteIndex) ^= IOSByteArray_Get(nil_chk(self->buffer_), byteIndex);
    }
    [((id<OrgSpongycastleCryptoBlockCipher>) nil_chk(self->engine_)) processBlockWithByteArray:self->macBlock_ withInt:0 withByteArray:self->macBlock_ withInt:0];
    return;
  }
  for (jint byteIndex = 0; byteIndex < [((id<OrgSpongycastleCryptoBlockCipher>) nil_chk(self->engine_)) getBlockSize]; byteIndex++) {
    *IOSByteArray_GetRef(nil_chk(self->macBlock_), byteIndex) ^= IOSByteArray_Get(nil_chk(self->buffer_), byteIndex);
  }
  [((id<OrgSpongycastleCryptoBlockCipher>) nil_chk(self->engine_)) processBlockWithByteArray:self->macBlock_ withInt:0 withByteArray:self->macBlock_ withInt:0];
  jint authLen = assocLen;
  while (authLen != 0) {
    for (jint byteIndex = 0; byteIndex < [((id<OrgSpongycastleCryptoBlockCipher>) nil_chk(self->engine_)) getBlockSize]; byteIndex++) {
      *IOSByteArray_GetRef(nil_chk(self->macBlock_), byteIndex) ^= IOSByteArray_Get(nil_chk(assocText), byteIndex + assocOff);
    }
    [((id<OrgSpongycastleCryptoBlockCipher>) nil_chk(self->engine_)) processBlockWithByteArray:self->macBlock_ withInt:0 withByteArray:self->macBlock_ withInt:0];
    assocOff += [((id<OrgSpongycastleCryptoBlockCipher>) nil_chk(self->engine_)) getBlockSize];
    authLen -= [((id<OrgSpongycastleCryptoBlockCipher>) nil_chk(self->engine_)) getBlockSize];
  }
}

void OrgSpongycastleCryptoModesKCCMBlockCipher_ProcessBlockWithByteArray_withInt_withInt_withByteArray_withInt_(OrgSpongycastleCryptoModesKCCMBlockCipher *self, IOSByteArray *input, jint inOff, jint len, IOSByteArray *output, jint outOff) {
  for (jint byteIndex = 0; byteIndex < ((IOSByteArray *) nil_chk(self->counter_))->size_; byteIndex++) {
    *IOSByteArray_GetRef(nil_chk(self->s_), byteIndex) += IOSByteArray_Get(self->counter_, byteIndex);
  }
  [((id<OrgSpongycastleCryptoBlockCipher>) nil_chk(self->engine_)) processBlockWithByteArray:self->s_ withInt:0 withByteArray:self->buffer_ withInt:0];
  for (jint byteIndex = 0; byteIndex < [((id<OrgSpongycastleCryptoBlockCipher>) nil_chk(self->engine_)) getBlockSize]; byteIndex++) {
    *IOSByteArray_GetRef(nil_chk(output), outOff + byteIndex) = (jbyte) (IOSByteArray_Get(nil_chk(self->buffer_), byteIndex) ^ IOSByteArray_Get(nil_chk(input), inOff + byteIndex));
  }
}

void OrgSpongycastleCryptoModesKCCMBlockCipher_CalculateMacWithByteArray_withInt_withInt_(OrgSpongycastleCryptoModesKCCMBlockCipher *self, IOSByteArray *authText, jint authOff, jint len) {
  jint totalLen = len;
  while (totalLen > 0) {
    for (jint byteIndex = 0; byteIndex < [((id<OrgSpongycastleCryptoBlockCipher>) nil_chk(self->engine_)) getBlockSize]; byteIndex++) {
      *IOSByteArray_GetRef(nil_chk(self->macBlock_), byteIndex) ^= IOSByteArray_Get(nil_chk(authText), authOff + byteIndex);
    }
    [((id<OrgSpongycastleCryptoBlockCipher>) nil_chk(self->engine_)) processBlockWithByteArray:self->macBlock_ withInt:0 withByteArray:self->macBlock_ withInt:0];
    totalLen -= [((id<OrgSpongycastleCryptoBlockCipher>) nil_chk(self->engine_)) getBlockSize];
    authOff += [((id<OrgSpongycastleCryptoBlockCipher>) nil_chk(self->engine_)) getBlockSize];
  }
}

void OrgSpongycastleCryptoModesKCCMBlockCipher_intToBytesWithInt_withByteArray_withInt_(OrgSpongycastleCryptoModesKCCMBlockCipher *self, jint num, IOSByteArray *outBytes, jint outOff) {
  *IOSByteArray_GetRef(nil_chk(outBytes), outOff + 3) = (jbyte) (JreRShift32(num, 24));
  *IOSByteArray_GetRef(outBytes, outOff + 2) = (jbyte) (JreRShift32(num, 16));
  *IOSByteArray_GetRef(outBytes, outOff + 1) = (jbyte) (JreRShift32(num, 8));
  *IOSByteArray_GetRef(outBytes, outOff) = (jbyte) num;
}

jbyte OrgSpongycastleCryptoModesKCCMBlockCipher_getFlagWithBoolean_withInt_(OrgSpongycastleCryptoModesKCCMBlockCipher *self, jboolean authTextPresents, jint macSize) {
  JavaLangStringBuffer *flagByte = new_JavaLangStringBuffer_init();
  if (authTextPresents) {
    (void) [flagByte appendWithNSString:@"1"];
  }
  else {
    (void) [flagByte appendWithNSString:@"0"];
  }
  switch (macSize) {
    case 8:
    (void) [flagByte appendWithNSString:@"010"];
    break;
    case 16:
    (void) [flagByte appendWithNSString:@"011"];
    break;
    case 32:
    (void) [flagByte appendWithNSString:@"100"];
    break;
    case 48:
    (void) [flagByte appendWithNSString:@"101"];
    break;
    case 64:
    (void) [flagByte appendWithNSString:@"110"];
    break;
  }
  NSString *binaryNb = JavaLangInteger_toBinaryStringWithInt_(self->Nb__ - 1);
  while ([((NSString *) nil_chk(binaryNb)) java_length] < 4) {
    binaryNb = [((JavaLangStringBuffer *) nil_chk([new_JavaLangStringBuffer_initWithNSString_(binaryNb) insertWithInt:0 withNSString:@"0"])) description];
  }
  (void) [flagByte appendWithNSString:binaryNb];
  return (jbyte) JavaLangInteger_parseIntWithNSString_withInt_([flagByte description], 2);
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(OrgSpongycastleCryptoModesKCCMBlockCipher)

@implementation OrgSpongycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream

- (instancetype)initWithOrgSpongycastleCryptoModesKCCMBlockCipher:(OrgSpongycastleCryptoModesKCCMBlockCipher *)outer$ {
  OrgSpongycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream_initWithOrgSpongycastleCryptoModesKCCMBlockCipher_(self, outer$);
  return self;
}

- (IOSByteArray *)getBuffer {
  return self->buf_;
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "[B", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithOrgSpongycastleCryptoModesKCCMBlockCipher:);
  methods[1].selector = @selector(getBuffer);
  #pragma clang diagnostic pop
  static const void *ptrTable[] = { "LOrgSpongycastleCryptoModesKCCMBlockCipher;" };
  static const J2ObjcClassInfo _OrgSpongycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream = { "ExposedByteArrayOutputStream", "org.spongycastle.crypto.modes", ptrTable, methods, NULL, 7, 0x2, 2, 0, 0, -1, -1, -1, -1 };
  return &_OrgSpongycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream;
}

@end

void OrgSpongycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream_initWithOrgSpongycastleCryptoModesKCCMBlockCipher_(OrgSpongycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream *self, OrgSpongycastleCryptoModesKCCMBlockCipher *outer$) {
  JavaIoByteArrayOutputStream_init(self);
}

OrgSpongycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream *new_OrgSpongycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream_initWithOrgSpongycastleCryptoModesKCCMBlockCipher_(OrgSpongycastleCryptoModesKCCMBlockCipher *outer$) {
  J2OBJC_NEW_IMPL(OrgSpongycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream, initWithOrgSpongycastleCryptoModesKCCMBlockCipher_, outer$)
}

OrgSpongycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream *create_OrgSpongycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream_initWithOrgSpongycastleCryptoModesKCCMBlockCipher_(OrgSpongycastleCryptoModesKCCMBlockCipher *outer$) {
  J2OBJC_CREATE_IMPL(OrgSpongycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream, initWithOrgSpongycastleCryptoModesKCCMBlockCipher_, outer$)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(OrgSpongycastleCryptoModesKCCMBlockCipher_ExposedByteArrayOutputStream)
