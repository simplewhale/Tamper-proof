//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/alen/Downloads/signMessage-api/target/classes/core/org/spongycastle/crypto/modes/CCMBlockCipher.java
//

#include "IOSClass.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "java/io/ByteArrayOutputStream.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/System.h"
#include "org/spongycastle/crypto/BlockCipher.h"
#include "org/spongycastle/crypto/CipherParameters.h"
#include "org/spongycastle/crypto/DataLengthException.h"
#include "org/spongycastle/crypto/InvalidCipherTextException.h"
#include "org/spongycastle/crypto/Mac.h"
#include "org/spongycastle/crypto/OutputLengthException.h"
#include "org/spongycastle/crypto/macs/CBCBlockCipherMac.h"
#include "org/spongycastle/crypto/modes/CCMBlockCipher.h"
#include "org/spongycastle/crypto/modes/SICBlockCipher.h"
#include "org/spongycastle/crypto/params/AEADParameters.h"
#include "org/spongycastle/crypto/params/KeyParameter.h"
#include "org/spongycastle/crypto/params/ParametersWithIV.h"
#include "org/spongycastle/util/Arrays.h"

@class OrgSpongycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream;

@interface OrgSpongycastleCryptoModesCCMBlockCipher () {
 @public
  id<OrgSpongycastleCryptoBlockCipher> cipher_;
  jint blockSize_;
  jboolean forEncryption_;
  IOSByteArray *nonce_;
  IOSByteArray *initialAssociatedText_;
  jint macSize_;
  id<OrgSpongycastleCryptoCipherParameters> keyParam_;
  IOSByteArray *macBlock_;
  OrgSpongycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream *associatedText_;
  OrgSpongycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream *data_;
}

- (jint)calculateMacWithByteArray:(IOSByteArray *)data
                          withInt:(jint)dataOff
                          withInt:(jint)dataLen
                    withByteArray:(IOSByteArray *)macBlock;

- (jint)getAssociatedTextLength;

- (jboolean)hasAssociatedText;

@end

J2OBJC_FIELD_SETTER(OrgSpongycastleCryptoModesCCMBlockCipher, cipher_, id<OrgSpongycastleCryptoBlockCipher>)
J2OBJC_FIELD_SETTER(OrgSpongycastleCryptoModesCCMBlockCipher, nonce_, IOSByteArray *)
J2OBJC_FIELD_SETTER(OrgSpongycastleCryptoModesCCMBlockCipher, initialAssociatedText_, IOSByteArray *)
J2OBJC_FIELD_SETTER(OrgSpongycastleCryptoModesCCMBlockCipher, keyParam_, id<OrgSpongycastleCryptoCipherParameters>)
J2OBJC_FIELD_SETTER(OrgSpongycastleCryptoModesCCMBlockCipher, macBlock_, IOSByteArray *)
J2OBJC_FIELD_SETTER(OrgSpongycastleCryptoModesCCMBlockCipher, associatedText_, OrgSpongycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream *)
J2OBJC_FIELD_SETTER(OrgSpongycastleCryptoModesCCMBlockCipher, data_, OrgSpongycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream *)

__attribute__((unused)) static jint OrgSpongycastleCryptoModesCCMBlockCipher_calculateMacWithByteArray_withInt_withInt_withByteArray_(OrgSpongycastleCryptoModesCCMBlockCipher *self, IOSByteArray *data, jint dataOff, jint dataLen, IOSByteArray *macBlock);

__attribute__((unused)) static jint OrgSpongycastleCryptoModesCCMBlockCipher_getAssociatedTextLength(OrgSpongycastleCryptoModesCCMBlockCipher *self);

__attribute__((unused)) static jboolean OrgSpongycastleCryptoModesCCMBlockCipher_hasAssociatedText(OrgSpongycastleCryptoModesCCMBlockCipher *self);

@interface OrgSpongycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream : JavaIoByteArrayOutputStream

- (instancetype)initWithOrgSpongycastleCryptoModesCCMBlockCipher:(OrgSpongycastleCryptoModesCCMBlockCipher *)outer$;

- (IOSByteArray *)getBuffer;

@end

J2OBJC_EMPTY_STATIC_INIT(OrgSpongycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream)

__attribute__((unused)) static void OrgSpongycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream_initWithOrgSpongycastleCryptoModesCCMBlockCipher_(OrgSpongycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream *self, OrgSpongycastleCryptoModesCCMBlockCipher *outer$);

__attribute__((unused)) static OrgSpongycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream *new_OrgSpongycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream_initWithOrgSpongycastleCryptoModesCCMBlockCipher_(OrgSpongycastleCryptoModesCCMBlockCipher *outer$) NS_RETURNS_RETAINED;

__attribute__((unused)) static OrgSpongycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream *create_OrgSpongycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream_initWithOrgSpongycastleCryptoModesCCMBlockCipher_(OrgSpongycastleCryptoModesCCMBlockCipher *outer$);

J2OBJC_TYPE_LITERAL_HEADER(OrgSpongycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream)

@implementation OrgSpongycastleCryptoModesCCMBlockCipher

- (instancetype)initWithOrgSpongycastleCryptoBlockCipher:(id<OrgSpongycastleCryptoBlockCipher>)c {
  OrgSpongycastleCryptoModesCCMBlockCipher_initWithOrgSpongycastleCryptoBlockCipher_(self, c);
  return self;
}

- (id<OrgSpongycastleCryptoBlockCipher>)getUnderlyingCipher {
  return cipher_;
}

- (void)init__WithBoolean:(jboolean)forEncryption
withOrgSpongycastleCryptoCipherParameters:(id<OrgSpongycastleCryptoCipherParameters>)params {
  self->forEncryption_ = forEncryption;
  id<OrgSpongycastleCryptoCipherParameters> cipherParameters;
  if ([params isKindOfClass:[OrgSpongycastleCryptoParamsAEADParameters class]]) {
    OrgSpongycastleCryptoParamsAEADParameters *param = (OrgSpongycastleCryptoParamsAEADParameters *) params;
    nonce_ = [((OrgSpongycastleCryptoParamsAEADParameters *) nil_chk(param)) getNonce];
    initialAssociatedText_ = [param getAssociatedText];
    macSize_ = [param getMacSize] / 8;
    cipherParameters = [param getKey];
  }
  else if ([params isKindOfClass:[OrgSpongycastleCryptoParamsParametersWithIV class]]) {
    OrgSpongycastleCryptoParamsParametersWithIV *param = (OrgSpongycastleCryptoParamsParametersWithIV *) params;
    nonce_ = [((OrgSpongycastleCryptoParamsParametersWithIV *) nil_chk(param)) getIV];
    initialAssociatedText_ = nil;
    macSize_ = ((IOSByteArray *) nil_chk(macBlock_))->size_ / 2;
    cipherParameters = [param getParameters];
  }
  else {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$$", @"invalid parameters passed to CCM: ", [[((id<OrgSpongycastleCryptoCipherParameters>) nil_chk(params)) java_getClass] getName]));
  }
  if (cipherParameters != nil) {
    keyParam_ = cipherParameters;
  }
  if (nonce_ == nil || nonce_->size_ < 7 || nonce_->size_ > 13) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"nonce must have length from 7 to 13 octets");
  }
  [self reset];
}

- (NSString *)getAlgorithmName {
  return JreStrcat("$$", [((id<OrgSpongycastleCryptoBlockCipher>) nil_chk(cipher_)) getAlgorithmName], @"/CCM");
}

- (void)processAADByteWithByte:(jbyte)inArg {
  [((OrgSpongycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(associatedText_)) writeWithInt:inArg];
}

- (void)processAADBytesWithByteArray:(IOSByteArray *)inArg
                             withInt:(jint)inOff
                             withInt:(jint)len {
  [((OrgSpongycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(associatedText_)) writeWithByteArray:inArg withInt:inOff withInt:len];
}

- (jint)processByteWithByte:(jbyte)inArg
              withByteArray:(IOSByteArray *)outArg
                    withInt:(jint)outOff {
  [((OrgSpongycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(data_)) writeWithInt:inArg];
  return 0;
}

- (jint)processBytesWithByteArray:(IOSByteArray *)inArg
                          withInt:(jint)inOff
                          withInt:(jint)inLen
                    withByteArray:(IOSByteArray *)outArg
                          withInt:(jint)outOff {
  if (((IOSByteArray *) nil_chk(inArg))->size_ < (inOff + inLen)) {
    @throw new_OrgSpongycastleCryptoDataLengthException_initWithNSString_(@"Input buffer too short");
  }
  [((OrgSpongycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(data_)) writeWithByteArray:inArg withInt:inOff withInt:inLen];
  return 0;
}

- (jint)doFinalWithByteArray:(IOSByteArray *)outArg
                     withInt:(jint)outOff {
  jint len = [self processPacketWithByteArray:[((OrgSpongycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(data_)) getBuffer] withInt:0 withInt:[((OrgSpongycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(data_)) size] withByteArray:outArg withInt:outOff];
  [self reset];
  return len;
}

- (void)reset {
  [((id<OrgSpongycastleCryptoBlockCipher>) nil_chk(cipher_)) reset];
  [((OrgSpongycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(associatedText_)) reset];
  [((OrgSpongycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(data_)) reset];
}

- (IOSByteArray *)getMac {
  IOSByteArray *mac = [IOSByteArray newArrayWithLength:macSize_];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(macBlock_, 0, mac, 0, mac->size_);
  return mac;
}

- (jint)getUpdateOutputSizeWithInt:(jint)len {
  return 0;
}

- (jint)getOutputSizeWithInt:(jint)len {
  jint totalData = len + [((OrgSpongycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(data_)) size];
  if (forEncryption_) {
    return totalData + macSize_;
  }
  return totalData < macSize_ ? 0 : totalData - macSize_;
}

- (IOSByteArray *)processPacketWithByteArray:(IOSByteArray *)inArg
                                     withInt:(jint)inOff
                                     withInt:(jint)inLen {
  IOSByteArray *output;
  if (forEncryption_) {
    output = [IOSByteArray newArrayWithLength:inLen + macSize_];
  }
  else {
    if (inLen < macSize_) {
      @throw new_OrgSpongycastleCryptoInvalidCipherTextException_initWithNSString_(@"data too short");
    }
    output = [IOSByteArray newArrayWithLength:inLen - macSize_];
  }
  [self processPacketWithByteArray:inArg withInt:inOff withInt:inLen withByteArray:output withInt:0];
  return output;
}

- (jint)processPacketWithByteArray:(IOSByteArray *)inArg
                           withInt:(jint)inOff
                           withInt:(jint)inLen
                     withByteArray:(IOSByteArray *)output
                           withInt:(jint)outOff {
  if (keyParam_ == nil) {
    @throw new_JavaLangIllegalStateException_initWithNSString_(@"CCM cipher unitialized.");
  }
  jint n = ((IOSByteArray *) nil_chk(nonce_))->size_;
  jint q = 15 - n;
  if (q < 4) {
    jint limitLen = JreLShift32(1, (8 * q));
    if (inLen >= limitLen) {
      @throw new_JavaLangIllegalStateException_initWithNSString_(@"CCM packet too large for choice of q.");
    }
  }
  IOSByteArray *iv = [IOSByteArray newArrayWithLength:blockSize_];
  *IOSByteArray_GetRef(iv, 0) = (jbyte) ((q - 1) & (jint) 0x7);
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(nonce_, 0, iv, 1, nonce_->size_);
  id<OrgSpongycastleCryptoBlockCipher> ctrCipher = new_OrgSpongycastleCryptoModesSICBlockCipher_initWithOrgSpongycastleCryptoBlockCipher_(cipher_);
  [ctrCipher init__WithBoolean:forEncryption_ withOrgSpongycastleCryptoCipherParameters:new_OrgSpongycastleCryptoParamsParametersWithIV_initWithOrgSpongycastleCryptoCipherParameters_withByteArray_(keyParam_, iv)];
  jint outputLen;
  jint inIndex = inOff;
  jint outIndex = outOff;
  if (forEncryption_) {
    outputLen = inLen + macSize_;
    if (((IOSByteArray *) nil_chk(output))->size_ < (outputLen + outOff)) {
      @throw new_OrgSpongycastleCryptoOutputLengthException_initWithNSString_(@"Output buffer too short.");
    }
    OrgSpongycastleCryptoModesCCMBlockCipher_calculateMacWithByteArray_withInt_withInt_withByteArray_(self, inArg, inOff, inLen, macBlock_);
    IOSByteArray *encMac = [IOSByteArray newArrayWithLength:blockSize_];
    [ctrCipher processBlockWithByteArray:macBlock_ withInt:0 withByteArray:encMac withInt:0];
    while (inIndex < (inOff + inLen - blockSize_)) {
      [ctrCipher processBlockWithByteArray:inArg withInt:inIndex withByteArray:output withInt:outIndex];
      outIndex += blockSize_;
      inIndex += blockSize_;
    }
    IOSByteArray *block = [IOSByteArray newArrayWithLength:blockSize_];
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(inArg, inIndex, block, 0, inLen + inOff - inIndex);
    [ctrCipher processBlockWithByteArray:block withInt:0 withByteArray:block withInt:0];
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(block, 0, output, outIndex, inLen + inOff - inIndex);
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(encMac, 0, output, outOff + inLen, macSize_);
  }
  else {
    if (inLen < macSize_) {
      @throw new_OrgSpongycastleCryptoInvalidCipherTextException_initWithNSString_(@"data too short");
    }
    outputLen = inLen - macSize_;
    if (((IOSByteArray *) nil_chk(output))->size_ < (outputLen + outOff)) {
      @throw new_OrgSpongycastleCryptoOutputLengthException_initWithNSString_(@"Output buffer too short.");
    }
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(inArg, inOff + outputLen, macBlock_, 0, macSize_);
    [ctrCipher processBlockWithByteArray:macBlock_ withInt:0 withByteArray:macBlock_ withInt:0];
    for (jint i = macSize_; i != ((IOSByteArray *) nil_chk(macBlock_))->size_; i++) {
      *IOSByteArray_GetRef(macBlock_, i) = 0;
    }
    while (inIndex < (inOff + outputLen - blockSize_)) {
      [ctrCipher processBlockWithByteArray:inArg withInt:inIndex withByteArray:output withInt:outIndex];
      outIndex += blockSize_;
      inIndex += blockSize_;
    }
    IOSByteArray *block = [IOSByteArray newArrayWithLength:blockSize_];
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(inArg, inIndex, block, 0, outputLen - (inIndex - inOff));
    [ctrCipher processBlockWithByteArray:block withInt:0 withByteArray:block withInt:0];
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(block, 0, output, outIndex, outputLen - (inIndex - inOff));
    IOSByteArray *calculatedMacBlock = [IOSByteArray newArrayWithLength:blockSize_];
    OrgSpongycastleCryptoModesCCMBlockCipher_calculateMacWithByteArray_withInt_withInt_withByteArray_(self, output, outOff, outputLen, calculatedMacBlock);
    if (!OrgSpongycastleUtilArrays_constantTimeAreEqualWithByteArray_withByteArray_(macBlock_, calculatedMacBlock)) {
      @throw new_OrgSpongycastleCryptoInvalidCipherTextException_initWithNSString_(@"mac check in CCM failed");
    }
  }
  return outputLen;
}

- (jint)calculateMacWithByteArray:(IOSByteArray *)data
                          withInt:(jint)dataOff
                          withInt:(jint)dataLen
                    withByteArray:(IOSByteArray *)macBlock {
  return OrgSpongycastleCryptoModesCCMBlockCipher_calculateMacWithByteArray_withInt_withInt_withByteArray_(self, data, dataOff, dataLen, macBlock);
}

- (jint)getAssociatedTextLength {
  return OrgSpongycastleCryptoModesCCMBlockCipher_getAssociatedTextLength(self);
}

- (jboolean)hasAssociatedText {
  return OrgSpongycastleCryptoModesCCMBlockCipher_hasAssociatedText(self);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "LOrgSpongycastleCryptoBlockCipher;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 1, 2, 3, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 4, 5, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 6, 7, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 8, 9, 10, -1, -1, -1 },
    { NULL, "I", 0x1, 11, 12, 10, -1, -1, -1 },
    { NULL, "I", 0x1, 13, 14, 15, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "[B", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 16, 17, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 18, 17, -1, -1, -1, -1 },
    { NULL, "[B", 0x1, 19, 7, 15, -1, -1, -1 },
    { NULL, "I", 0x1, 19, 12, 20, -1, -1, -1 },
    { NULL, "I", 0x2, 21, 22, -1, -1, -1, -1 },
    { NULL, "I", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x2, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithOrgSpongycastleCryptoBlockCipher:);
  methods[1].selector = @selector(getUnderlyingCipher);
  methods[2].selector = @selector(init__WithBoolean:withOrgSpongycastleCryptoCipherParameters:);
  methods[3].selector = @selector(getAlgorithmName);
  methods[4].selector = @selector(processAADByteWithByte:);
  methods[5].selector = @selector(processAADBytesWithByteArray:withInt:withInt:);
  methods[6].selector = @selector(processByteWithByte:withByteArray:withInt:);
  methods[7].selector = @selector(processBytesWithByteArray:withInt:withInt:withByteArray:withInt:);
  methods[8].selector = @selector(doFinalWithByteArray:withInt:);
  methods[9].selector = @selector(reset);
  methods[10].selector = @selector(getMac);
  methods[11].selector = @selector(getUpdateOutputSizeWithInt:);
  methods[12].selector = @selector(getOutputSizeWithInt:);
  methods[13].selector = @selector(processPacketWithByteArray:withInt:withInt:);
  methods[14].selector = @selector(processPacketWithByteArray:withInt:withInt:withByteArray:withInt:);
  methods[15].selector = @selector(calculateMacWithByteArray:withInt:withInt:withByteArray:);
  methods[16].selector = @selector(getAssociatedTextLength);
  methods[17].selector = @selector(hasAssociatedText);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "cipher_", "LOrgSpongycastleCryptoBlockCipher;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "blockSize_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "forEncryption_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "nonce_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "initialAssociatedText_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "macSize_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "keyParam_", "LOrgSpongycastleCryptoCipherParameters;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "macBlock_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "associatedText_", "LOrgSpongycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "data_", "LOrgSpongycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LOrgSpongycastleCryptoBlockCipher;", "init", "ZLOrgSpongycastleCryptoCipherParameters;", "LJavaLangIllegalArgumentException;", "processAADByte", "B", "processAADBytes", "[BII", "processByte", "B[BI", "LOrgSpongycastleCryptoDataLengthException;LJavaLangIllegalStateException;", "processBytes", "[BII[BI", "doFinal", "[BI", "LJavaLangIllegalStateException;LOrgSpongycastleCryptoInvalidCipherTextException;", "getUpdateOutputSize", "I", "getOutputSize", "processPacket", "LJavaLangIllegalStateException;LOrgSpongycastleCryptoInvalidCipherTextException;LOrgSpongycastleCryptoDataLengthException;", "calculateMac", "[BII[B", "LOrgSpongycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream;" };
  static const J2ObjcClassInfo _OrgSpongycastleCryptoModesCCMBlockCipher = { "CCMBlockCipher", "org.spongycastle.crypto.modes", ptrTable, methods, fields, 7, 0x1, 18, 10, -1, 23, -1, -1, -1 };
  return &_OrgSpongycastleCryptoModesCCMBlockCipher;
}

@end

void OrgSpongycastleCryptoModesCCMBlockCipher_initWithOrgSpongycastleCryptoBlockCipher_(OrgSpongycastleCryptoModesCCMBlockCipher *self, id<OrgSpongycastleCryptoBlockCipher> c) {
  NSObject_init(self);
  self->associatedText_ = new_OrgSpongycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream_initWithOrgSpongycastleCryptoModesCCMBlockCipher_(self);
  self->data_ = new_OrgSpongycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream_initWithOrgSpongycastleCryptoModesCCMBlockCipher_(self);
  self->cipher_ = c;
  self->blockSize_ = [((id<OrgSpongycastleCryptoBlockCipher>) nil_chk(c)) getBlockSize];
  self->macBlock_ = [IOSByteArray newArrayWithLength:self->blockSize_];
  if (self->blockSize_ != 16) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"cipher required with a block size of 16.");
  }
}

OrgSpongycastleCryptoModesCCMBlockCipher *new_OrgSpongycastleCryptoModesCCMBlockCipher_initWithOrgSpongycastleCryptoBlockCipher_(id<OrgSpongycastleCryptoBlockCipher> c) {
  J2OBJC_NEW_IMPL(OrgSpongycastleCryptoModesCCMBlockCipher, initWithOrgSpongycastleCryptoBlockCipher_, c)
}

OrgSpongycastleCryptoModesCCMBlockCipher *create_OrgSpongycastleCryptoModesCCMBlockCipher_initWithOrgSpongycastleCryptoBlockCipher_(id<OrgSpongycastleCryptoBlockCipher> c) {
  J2OBJC_CREATE_IMPL(OrgSpongycastleCryptoModesCCMBlockCipher, initWithOrgSpongycastleCryptoBlockCipher_, c)
}

jint OrgSpongycastleCryptoModesCCMBlockCipher_calculateMacWithByteArray_withInt_withInt_withByteArray_(OrgSpongycastleCryptoModesCCMBlockCipher *self, IOSByteArray *data, jint dataOff, jint dataLen, IOSByteArray *macBlock) {
  id<OrgSpongycastleCryptoMac> cMac = new_OrgSpongycastleCryptoMacsCBCBlockCipherMac_initWithOrgSpongycastleCryptoBlockCipher_withInt_(self->cipher_, self->macSize_ * 8);
  [cMac init__WithOrgSpongycastleCryptoCipherParameters:self->keyParam_];
  IOSByteArray *b0 = [IOSByteArray newArrayWithLength:16];
  if (OrgSpongycastleCryptoModesCCMBlockCipher_hasAssociatedText(self)) {
    *IOSByteArray_GetRef(b0, 0) |= (jint) 0x40;
  }
  *IOSByteArray_GetRef(b0, 0) |= JreLShift32(((([cMac getMacSize] - 2) / 2) & (jint) 0x7), 3);
  *IOSByteArray_GetRef(b0, 0) |= ((15 - ((IOSByteArray *) nil_chk(self->nonce_))->size_) - 1) & (jint) 0x7;
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(self->nonce_, 0, b0, 1, self->nonce_->size_);
  jint q = dataLen;
  jint count = 1;
  while (q > 0) {
    *IOSByteArray_GetRef(b0, b0->size_ - count) = (jbyte) (q & (jint) 0xff);
    JreURShiftAssignInt(&q, 8);
    count++;
  }
  [cMac updateWithByteArray:b0 withInt:0 withInt:b0->size_];
  if (OrgSpongycastleCryptoModesCCMBlockCipher_hasAssociatedText(self)) {
    jint extra;
    jint textLength = OrgSpongycastleCryptoModesCCMBlockCipher_getAssociatedTextLength(self);
    if (textLength < ((JreLShift32(1, 16)) - (JreLShift32(1, 8)))) {
      [cMac updateWithByte:(jbyte) (JreRShift32(textLength, 8))];
      [cMac updateWithByte:(jbyte) textLength];
      extra = 2;
    }
    else {
      [cMac updateWithByte:(jbyte) (jint) 0xff];
      [cMac updateWithByte:(jbyte) (jint) 0xfe];
      [cMac updateWithByte:(jbyte) (JreRShift32(textLength, 24))];
      [cMac updateWithByte:(jbyte) (JreRShift32(textLength, 16))];
      [cMac updateWithByte:(jbyte) (JreRShift32(textLength, 8))];
      [cMac updateWithByte:(jbyte) textLength];
      extra = 6;
    }
    if (self->initialAssociatedText_ != nil) {
      [cMac updateWithByteArray:self->initialAssociatedText_ withInt:0 withInt:self->initialAssociatedText_->size_];
    }
    if ([((OrgSpongycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(self->associatedText_)) size] > 0) {
      [cMac updateWithByteArray:[((OrgSpongycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(self->associatedText_)) getBuffer] withInt:0 withInt:[((OrgSpongycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(self->associatedText_)) size]];
    }
    extra = (extra + textLength) % 16;
    if (extra != 0) {
      for (jint i = extra; i != 16; i++) {
        [cMac updateWithByte:(jbyte) (jint) 0x00];
      }
    }
  }
  [cMac updateWithByteArray:data withInt:dataOff withInt:dataLen];
  return [cMac doFinalWithByteArray:macBlock withInt:0];
}

jint OrgSpongycastleCryptoModesCCMBlockCipher_getAssociatedTextLength(OrgSpongycastleCryptoModesCCMBlockCipher *self) {
  return [((OrgSpongycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream *) nil_chk(self->associatedText_)) size] + ((self->initialAssociatedText_ == nil) ? 0 : ((IOSByteArray *) nil_chk(self->initialAssociatedText_))->size_);
}

jboolean OrgSpongycastleCryptoModesCCMBlockCipher_hasAssociatedText(OrgSpongycastleCryptoModesCCMBlockCipher *self) {
  return OrgSpongycastleCryptoModesCCMBlockCipher_getAssociatedTextLength(self) > 0;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(OrgSpongycastleCryptoModesCCMBlockCipher)

@implementation OrgSpongycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream

- (instancetype)initWithOrgSpongycastleCryptoModesCCMBlockCipher:(OrgSpongycastleCryptoModesCCMBlockCipher *)outer$ {
  OrgSpongycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream_initWithOrgSpongycastleCryptoModesCCMBlockCipher_(self, outer$);
  return self;
}

- (IOSByteArray *)getBuffer {
  return self->buf_;
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "[B", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithOrgSpongycastleCryptoModesCCMBlockCipher:);
  methods[1].selector = @selector(getBuffer);
  #pragma clang diagnostic pop
  static const void *ptrTable[] = { "LOrgSpongycastleCryptoModesCCMBlockCipher;" };
  static const J2ObjcClassInfo _OrgSpongycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream = { "ExposedByteArrayOutputStream", "org.spongycastle.crypto.modes", ptrTable, methods, NULL, 7, 0x2, 2, 0, 0, -1, -1, -1, -1 };
  return &_OrgSpongycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream;
}

@end

void OrgSpongycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream_initWithOrgSpongycastleCryptoModesCCMBlockCipher_(OrgSpongycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream *self, OrgSpongycastleCryptoModesCCMBlockCipher *outer$) {
  JavaIoByteArrayOutputStream_init(self);
}

OrgSpongycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream *new_OrgSpongycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream_initWithOrgSpongycastleCryptoModesCCMBlockCipher_(OrgSpongycastleCryptoModesCCMBlockCipher *outer$) {
  J2OBJC_NEW_IMPL(OrgSpongycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream, initWithOrgSpongycastleCryptoModesCCMBlockCipher_, outer$)
}

OrgSpongycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream *create_OrgSpongycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream_initWithOrgSpongycastleCryptoModesCCMBlockCipher_(OrgSpongycastleCryptoModesCCMBlockCipher *outer$) {
  J2OBJC_CREATE_IMPL(OrgSpongycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream, initWithOrgSpongycastleCryptoModesCCMBlockCipher_, outer$)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(OrgSpongycastleCryptoModesCCMBlockCipher_ExposedByteArrayOutputStream)
