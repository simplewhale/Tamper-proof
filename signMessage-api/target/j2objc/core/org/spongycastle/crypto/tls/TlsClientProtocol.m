//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/alen/Downloads/signMessage-api/target/classes/core/org/spongycastle/crypto/tls/TlsClientProtocol.java
//

#include "IOSClass.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "java/io/ByteArrayInputStream.h"
#include "java/io/InputStream.h"
#include "java/io/OutputStream.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/Integer.h"
#include "java/security/SecureRandom.h"
#include "java/util/Enumeration.h"
#include "java/util/Hashtable.h"
#include "java/util/Vector.h"
#include "org/spongycastle/crypto/prng/RandomGenerator.h"
#include "org/spongycastle/crypto/tls/AbstractTlsContext.h"
#include "org/spongycastle/crypto/tls/AlertDescription.h"
#include "org/spongycastle/crypto/tls/Certificate.h"
#include "org/spongycastle/crypto/tls/CertificateRequest.h"
#include "org/spongycastle/crypto/tls/CertificateStatus.h"
#include "org/spongycastle/crypto/tls/CipherSuite.h"
#include "org/spongycastle/crypto/tls/ConnectionEnd.h"
#include "org/spongycastle/crypto/tls/DigitallySigned.h"
#include "org/spongycastle/crypto/tls/HandshakeType.h"
#include "org/spongycastle/crypto/tls/NewSessionTicket.h"
#include "org/spongycastle/crypto/tls/ProtocolVersion.h"
#include "org/spongycastle/crypto/tls/RecordStream.h"
#include "org/spongycastle/crypto/tls/SecurityParameters.h"
#include "org/spongycastle/crypto/tls/SessionParameters.h"
#include "org/spongycastle/crypto/tls/SignatureAndHashAlgorithm.h"
#include "org/spongycastle/crypto/tls/TlsAuthentication.h"
#include "org/spongycastle/crypto/tls/TlsCipher.h"
#include "org/spongycastle/crypto/tls/TlsClient.h"
#include "org/spongycastle/crypto/tls/TlsClientContextImpl.h"
#include "org/spongycastle/crypto/tls/TlsClientProtocol.h"
#include "org/spongycastle/crypto/tls/TlsCompression.h"
#include "org/spongycastle/crypto/tls/TlsContext.h"
#include "org/spongycastle/crypto/tls/TlsCredentials.h"
#include "org/spongycastle/crypto/tls/TlsExtensionsUtils.h"
#include "org/spongycastle/crypto/tls/TlsFatalAlert.h"
#include "org/spongycastle/crypto/tls/TlsHandshakeHash.h"
#include "org/spongycastle/crypto/tls/TlsKeyExchange.h"
#include "org/spongycastle/crypto/tls/TlsPeer.h"
#include "org/spongycastle/crypto/tls/TlsProtocol.h"
#include "org/spongycastle/crypto/tls/TlsSession.h"
#include "org/spongycastle/crypto/tls/TlsSessionImpl.h"
#include "org/spongycastle/crypto/tls/TlsSignerCredentials.h"
#include "org/spongycastle/crypto/tls/TlsUtils.h"
#include "org/spongycastle/util/Arrays.h"

@implementation OrgSpongycastleCryptoTlsTlsClientProtocol

- (instancetype)initWithJavaIoInputStream:(JavaIoInputStream *)input
                   withJavaIoOutputStream:(JavaIoOutputStream *)output
             withJavaSecuritySecureRandom:(JavaSecuritySecureRandom *)secureRandom {
  OrgSpongycastleCryptoTlsTlsClientProtocol_initWithJavaIoInputStream_withJavaIoOutputStream_withJavaSecuritySecureRandom_(self, input, output, secureRandom);
  return self;
}

- (instancetype)initWithJavaSecuritySecureRandom:(JavaSecuritySecureRandom *)secureRandom {
  OrgSpongycastleCryptoTlsTlsClientProtocol_initWithJavaSecuritySecureRandom_(self, secureRandom);
  return self;
}

- (void)connectWithOrgSpongycastleCryptoTlsTlsClient:(id<OrgSpongycastleCryptoTlsTlsClient>)tlsClient {
  if (tlsClient == nil) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"'tlsClient' cannot be null");
  }
  if (self->tlsClient_ != nil) {
    @throw new_JavaLangIllegalStateException_initWithNSString_(@"'connect' can only be called once");
  }
  self->tlsClient_ = tlsClient;
  self->securityParameters_ = new_OrgSpongycastleCryptoTlsSecurityParameters_init();
  self->securityParameters_->entity_ = OrgSpongycastleCryptoTlsConnectionEnd_client;
  self->tlsClientContext_ = new_OrgSpongycastleCryptoTlsTlsClientContextImpl_initWithJavaSecuritySecureRandom_withOrgSpongycastleCryptoTlsSecurityParameters_(secureRandom_, securityParameters_);
  ((OrgSpongycastleCryptoTlsSecurityParameters *) nil_chk(self->securityParameters_))->clientRandom_ = OrgSpongycastleCryptoTlsTlsProtocol_createRandomBlockWithBoolean_withOrgSpongycastleCryptoPrngRandomGenerator_([tlsClient shouldUseGMTUnixTime], [((OrgSpongycastleCryptoTlsTlsClientContextImpl *) nil_chk(tlsClientContext_)) getNonceRandomGenerator]);
  [((id<OrgSpongycastleCryptoTlsTlsClient>) nil_chk(self->tlsClient_)) init__WithOrgSpongycastleCryptoTlsTlsClientContext:tlsClientContext_];
  [((OrgSpongycastleCryptoTlsRecordStream *) nil_chk(self->recordStream_)) init__WithOrgSpongycastleCryptoTlsTlsContext:tlsClientContext_];
  id<OrgSpongycastleCryptoTlsTlsSession> sessionToResume = [tlsClient getSessionToResume];
  if (sessionToResume != nil && [sessionToResume isResumable]) {
    OrgSpongycastleCryptoTlsSessionParameters *sessionParameters = [sessionToResume exportSessionParameters];
    if (sessionParameters != nil) {
      self->tlsSession_ = sessionToResume;
      self->sessionParameters_ = sessionParameters;
    }
  }
  [self sendClientHelloMessage];
  self->connection_state_ = OrgSpongycastleCryptoTlsTlsProtocol_CS_CLIENT_HELLO;
  [self blockForHandshake];
}

- (void)cleanupHandshake {
  [super cleanupHandshake];
  self->selectedSessionID_ = nil;
  self->keyExchange_ = nil;
  self->authentication_ = nil;
  self->certificateStatus_ = nil;
  self->certificateRequest_ = nil;
}

- (id<OrgSpongycastleCryptoTlsTlsContext>)getContext {
  return tlsClientContext_;
}

- (OrgSpongycastleCryptoTlsAbstractTlsContext *)getContextAdmin {
  return tlsClientContext_;
}

- (id<OrgSpongycastleCryptoTlsTlsPeer>)getPeer {
  return tlsClient_;
}

- (void)handleHandshakeMessageWithShort:(jshort)type
         withJavaIoByteArrayInputStream:(JavaIoByteArrayInputStream *)buf {
  if (self->resumedSession_) {
    if (type != OrgSpongycastleCryptoTlsHandshakeType_finished || self->connection_state_ != OrgSpongycastleCryptoTlsTlsProtocol_CS_SERVER_HELLO) {
      @throw new_OrgSpongycastleCryptoTlsTlsFatalAlert_initWithShort_(OrgSpongycastleCryptoTlsAlertDescription_unexpected_message);
    }
    [self processFinishedMessageWithJavaIoByteArrayInputStream:buf];
    self->connection_state_ = OrgSpongycastleCryptoTlsTlsProtocol_CS_SERVER_FINISHED;
    [self sendFinishedMessage];
    self->connection_state_ = OrgSpongycastleCryptoTlsTlsProtocol_CS_CLIENT_FINISHED;
    [self completeHandshake];
    return;
  }
  switch (type) {
    case OrgSpongycastleCryptoTlsHandshakeType_certificate:
    {
      switch (self->connection_state_) {
        case OrgSpongycastleCryptoTlsTlsProtocol_CS_SERVER_HELLO:
        {
          [self handleSupplementalDataWithJavaUtilVector:nil];
        }
        case OrgSpongycastleCryptoTlsTlsProtocol_CS_SERVER_SUPPLEMENTAL_DATA:
        {
          self->peerCertificate_ = OrgSpongycastleCryptoTlsCertificate_parseWithJavaIoInputStream_(buf);
          OrgSpongycastleCryptoTlsTlsProtocol_assertEmptyWithJavaIoByteArrayInputStream_(buf);
          if (self->peerCertificate_ == nil || [self->peerCertificate_ isEmpty]) {
            self->allowCertificateStatus_ = false;
          }
          [((id<OrgSpongycastleCryptoTlsTlsKeyExchange>) nil_chk(self->keyExchange_)) processServerCertificateWithOrgSpongycastleCryptoTlsCertificate:self->peerCertificate_];
          self->authentication_ = [((id<OrgSpongycastleCryptoTlsTlsClient>) nil_chk(tlsClient_)) getAuthentication];
          [((id<OrgSpongycastleCryptoTlsTlsAuthentication>) nil_chk(self->authentication_)) notifyServerCertificateWithOrgSpongycastleCryptoTlsCertificate:self->peerCertificate_];
          break;
        }
        default:
        @throw new_OrgSpongycastleCryptoTlsTlsFatalAlert_initWithShort_(OrgSpongycastleCryptoTlsAlertDescription_unexpected_message);
      }
      self->connection_state_ = OrgSpongycastleCryptoTlsTlsProtocol_CS_SERVER_CERTIFICATE;
      break;
    }
    case OrgSpongycastleCryptoTlsHandshakeType_certificate_status:
    {
      switch (self->connection_state_) {
        case OrgSpongycastleCryptoTlsTlsProtocol_CS_SERVER_CERTIFICATE:
        {
          if (!self->allowCertificateStatus_) {
            @throw new_OrgSpongycastleCryptoTlsTlsFatalAlert_initWithShort_(OrgSpongycastleCryptoTlsAlertDescription_unexpected_message);
          }
          self->certificateStatus_ = OrgSpongycastleCryptoTlsCertificateStatus_parseWithJavaIoInputStream_(buf);
          OrgSpongycastleCryptoTlsTlsProtocol_assertEmptyWithJavaIoByteArrayInputStream_(buf);
          self->connection_state_ = OrgSpongycastleCryptoTlsTlsProtocol_CS_CERTIFICATE_STATUS;
          break;
        }
        default:
        @throw new_OrgSpongycastleCryptoTlsTlsFatalAlert_initWithShort_(OrgSpongycastleCryptoTlsAlertDescription_unexpected_message);
      }
      break;
    }
    case OrgSpongycastleCryptoTlsHandshakeType_finished:
    {
      switch (self->connection_state_) {
        case OrgSpongycastleCryptoTlsTlsProtocol_CS_CLIENT_FINISHED:
        {
          if (self->expectSessionTicket_) {
            @throw new_OrgSpongycastleCryptoTlsTlsFatalAlert_initWithShort_(OrgSpongycastleCryptoTlsAlertDescription_unexpected_message);
          }
        }
        case OrgSpongycastleCryptoTlsTlsProtocol_CS_SERVER_SESSION_TICKET:
        {
          [self processFinishedMessageWithJavaIoByteArrayInputStream:buf];
          self->connection_state_ = OrgSpongycastleCryptoTlsTlsProtocol_CS_SERVER_FINISHED;
          [self completeHandshake];
          break;
        }
        default:
        @throw new_OrgSpongycastleCryptoTlsTlsFatalAlert_initWithShort_(OrgSpongycastleCryptoTlsAlertDescription_unexpected_message);
      }
      break;
    }
    case OrgSpongycastleCryptoTlsHandshakeType_server_hello:
    {
      switch (self->connection_state_) {
        case OrgSpongycastleCryptoTlsTlsProtocol_CS_CLIENT_HELLO:
        {
          [self receiveServerHelloMessageWithJavaIoByteArrayInputStream:buf];
          self->connection_state_ = OrgSpongycastleCryptoTlsTlsProtocol_CS_SERVER_HELLO;
          [((OrgSpongycastleCryptoTlsRecordStream *) nil_chk(self->recordStream_)) notifyHelloComplete];
          [self applyMaxFragmentLengthExtension];
          if (self->resumedSession_) {
            ((OrgSpongycastleCryptoTlsSecurityParameters *) nil_chk(self->securityParameters_))->masterSecret_ = OrgSpongycastleUtilArrays_cloneWithByteArray_([((OrgSpongycastleCryptoTlsSessionParameters *) nil_chk(self->sessionParameters_)) getMasterSecret]);
            [((OrgSpongycastleCryptoTlsRecordStream *) nil_chk(self->recordStream_)) setPendingConnectionStateWithOrgSpongycastleCryptoTlsTlsCompression:[((id<OrgSpongycastleCryptoTlsTlsPeer>) nil_chk([self getPeer])) getCompression] withOrgSpongycastleCryptoTlsTlsCipher:[((id<OrgSpongycastleCryptoTlsTlsPeer>) nil_chk([self getPeer])) getCipher]];
            [self sendChangeCipherSpecMessage];
          }
          else {
            [self invalidateSession];
            if (((IOSByteArray *) nil_chk(self->selectedSessionID_))->size_ > 0) {
              self->tlsSession_ = new_OrgSpongycastleCryptoTlsTlsSessionImpl_initWithByteArray_withOrgSpongycastleCryptoTlsSessionParameters_(self->selectedSessionID_, nil);
            }
          }
          break;
        }
        default:
        @throw new_OrgSpongycastleCryptoTlsTlsFatalAlert_initWithShort_(OrgSpongycastleCryptoTlsAlertDescription_unexpected_message);
      }
      break;
    }
    case OrgSpongycastleCryptoTlsHandshakeType_supplemental_data:
    {
      switch (self->connection_state_) {
        case OrgSpongycastleCryptoTlsTlsProtocol_CS_SERVER_HELLO:
        {
          [self handleSupplementalDataWithJavaUtilVector:OrgSpongycastleCryptoTlsTlsProtocol_readSupplementalDataMessageWithJavaIoByteArrayInputStream_(buf)];
          break;
        }
        default:
        @throw new_OrgSpongycastleCryptoTlsTlsFatalAlert_initWithShort_(OrgSpongycastleCryptoTlsAlertDescription_unexpected_message);
      }
      break;
    }
    case OrgSpongycastleCryptoTlsHandshakeType_server_hello_done:
    {
      switch (self->connection_state_) {
        case OrgSpongycastleCryptoTlsTlsProtocol_CS_SERVER_HELLO:
        {
          [self handleSupplementalDataWithJavaUtilVector:nil];
        }
        case OrgSpongycastleCryptoTlsTlsProtocol_CS_SERVER_SUPPLEMENTAL_DATA:
        {
          [((id<OrgSpongycastleCryptoTlsTlsKeyExchange>) nil_chk(self->keyExchange_)) skipServerCredentials];
          self->authentication_ = nil;
        }
        case OrgSpongycastleCryptoTlsTlsProtocol_CS_SERVER_CERTIFICATE:
        case OrgSpongycastleCryptoTlsTlsProtocol_CS_CERTIFICATE_STATUS:
        {
          [((id<OrgSpongycastleCryptoTlsTlsKeyExchange>) nil_chk(self->keyExchange_)) skipServerKeyExchange];
        }
        case OrgSpongycastleCryptoTlsTlsProtocol_CS_SERVER_KEY_EXCHANGE:
        case OrgSpongycastleCryptoTlsTlsProtocol_CS_CERTIFICATE_REQUEST:
        {
          OrgSpongycastleCryptoTlsTlsProtocol_assertEmptyWithJavaIoByteArrayInputStream_(buf);
          self->connection_state_ = OrgSpongycastleCryptoTlsTlsProtocol_CS_SERVER_HELLO_DONE;
          [((id<OrgSpongycastleCryptoTlsTlsHandshakeHash>) nil_chk([((OrgSpongycastleCryptoTlsRecordStream *) nil_chk(self->recordStream_)) getHandshakeHash])) sealHashAlgorithms];
          JavaUtilVector *clientSupplementalData = [((id<OrgSpongycastleCryptoTlsTlsClient>) nil_chk(tlsClient_)) getClientSupplementalData];
          if (clientSupplementalData != nil) {
            [self sendSupplementalDataMessageWithJavaUtilVector:clientSupplementalData];
          }
          self->connection_state_ = OrgSpongycastleCryptoTlsTlsProtocol_CS_CLIENT_SUPPLEMENTAL_DATA;
          id<OrgSpongycastleCryptoTlsTlsCredentials> clientCreds = nil;
          if (certificateRequest_ == nil) {
            [((id<OrgSpongycastleCryptoTlsTlsKeyExchange>) nil_chk(self->keyExchange_)) skipClientCredentials];
          }
          else {
            clientCreds = [((id<OrgSpongycastleCryptoTlsTlsAuthentication>) nil_chk(self->authentication_)) getClientCredentialsWithOrgSpongycastleCryptoTlsCertificateRequest:certificateRequest_];
            if (clientCreds == nil) {
              [((id<OrgSpongycastleCryptoTlsTlsKeyExchange>) nil_chk(self->keyExchange_)) skipClientCredentials];
              [self sendCertificateMessageWithOrgSpongycastleCryptoTlsCertificate:JreLoadStatic(OrgSpongycastleCryptoTlsCertificate, EMPTY_CHAIN)];
            }
            else {
              [((id<OrgSpongycastleCryptoTlsTlsKeyExchange>) nil_chk(self->keyExchange_)) processClientCredentialsWithOrgSpongycastleCryptoTlsTlsCredentials:clientCreds];
              [self sendCertificateMessageWithOrgSpongycastleCryptoTlsCertificate:[clientCreds getCertificate]];
            }
          }
          self->connection_state_ = OrgSpongycastleCryptoTlsTlsProtocol_CS_CLIENT_CERTIFICATE;
          [self sendClientKeyExchangeMessage];
          self->connection_state_ = OrgSpongycastleCryptoTlsTlsProtocol_CS_CLIENT_KEY_EXCHANGE;
          if (OrgSpongycastleCryptoTlsTlsUtils_isSSLWithOrgSpongycastleCryptoTlsTlsContext_([self getContext])) {
            OrgSpongycastleCryptoTlsTlsProtocol_establishMasterSecretWithOrgSpongycastleCryptoTlsTlsContext_withOrgSpongycastleCryptoTlsTlsKeyExchange_([self getContext], keyExchange_);
          }
          id<OrgSpongycastleCryptoTlsTlsHandshakeHash> prepareFinishHash = [((OrgSpongycastleCryptoTlsRecordStream *) nil_chk(recordStream_)) prepareToFinish];
          ((OrgSpongycastleCryptoTlsSecurityParameters *) nil_chk(self->securityParameters_))->sessionHash_ = OrgSpongycastleCryptoTlsTlsProtocol_getCurrentPRFHashWithOrgSpongycastleCryptoTlsTlsContext_withOrgSpongycastleCryptoTlsTlsHandshakeHash_withByteArray_([self getContext], prepareFinishHash, nil);
          if (!OrgSpongycastleCryptoTlsTlsUtils_isSSLWithOrgSpongycastleCryptoTlsTlsContext_([self getContext])) {
            OrgSpongycastleCryptoTlsTlsProtocol_establishMasterSecretWithOrgSpongycastleCryptoTlsTlsContext_withOrgSpongycastleCryptoTlsTlsKeyExchange_([self getContext], keyExchange_);
          }
          [((OrgSpongycastleCryptoTlsRecordStream *) nil_chk(recordStream_)) setPendingConnectionStateWithOrgSpongycastleCryptoTlsTlsCompression:[((id<OrgSpongycastleCryptoTlsTlsPeer>) nil_chk([self getPeer])) getCompression] withOrgSpongycastleCryptoTlsTlsCipher:[((id<OrgSpongycastleCryptoTlsTlsPeer>) nil_chk([self getPeer])) getCipher]];
          if (clientCreds != nil && [OrgSpongycastleCryptoTlsTlsSignerCredentials_class_() isInstance:clientCreds]) {
            id<OrgSpongycastleCryptoTlsTlsSignerCredentials> signerCredentials = (id<OrgSpongycastleCryptoTlsTlsSignerCredentials>) cast_check(clientCreds, OrgSpongycastleCryptoTlsTlsSignerCredentials_class_());
            OrgSpongycastleCryptoTlsSignatureAndHashAlgorithm *signatureAndHashAlgorithm = OrgSpongycastleCryptoTlsTlsUtils_getSignatureAndHashAlgorithmWithOrgSpongycastleCryptoTlsTlsContext_withOrgSpongycastleCryptoTlsTlsSignerCredentials_([self getContext], signerCredentials);
            IOSByteArray *hash_;
            if (signatureAndHashAlgorithm == nil) {
              hash_ = [((OrgSpongycastleCryptoTlsSecurityParameters *) nil_chk(securityParameters_)) getSessionHash];
            }
            else {
              hash_ = [((id<OrgSpongycastleCryptoTlsTlsHandshakeHash>) nil_chk(prepareFinishHash)) getFinalHashWithShort:[signatureAndHashAlgorithm getHash]];
            }
            IOSByteArray *signature = [signerCredentials generateCertificateSignatureWithByteArray:hash_];
            OrgSpongycastleCryptoTlsDigitallySigned *certificateVerify = new_OrgSpongycastleCryptoTlsDigitallySigned_initWithOrgSpongycastleCryptoTlsSignatureAndHashAlgorithm_withByteArray_(signatureAndHashAlgorithm, signature);
            [self sendCertificateVerifyMessageWithOrgSpongycastleCryptoTlsDigitallySigned:certificateVerify];
            self->connection_state_ = OrgSpongycastleCryptoTlsTlsProtocol_CS_CERTIFICATE_VERIFY;
          }
          [self sendChangeCipherSpecMessage];
          [self sendFinishedMessage];
          break;
        }
        default:
        @throw new_OrgSpongycastleCryptoTlsTlsFatalAlert_initWithShort_(OrgSpongycastleCryptoTlsAlertDescription_unexpected_message);
      }
      self->connection_state_ = OrgSpongycastleCryptoTlsTlsProtocol_CS_CLIENT_FINISHED;
      break;
    }
    case OrgSpongycastleCryptoTlsHandshakeType_server_key_exchange:
    {
      switch (self->connection_state_) {
        case OrgSpongycastleCryptoTlsTlsProtocol_CS_SERVER_HELLO:
        {
          [self handleSupplementalDataWithJavaUtilVector:nil];
        }
        case OrgSpongycastleCryptoTlsTlsProtocol_CS_SERVER_SUPPLEMENTAL_DATA:
        {
          [((id<OrgSpongycastleCryptoTlsTlsKeyExchange>) nil_chk(self->keyExchange_)) skipServerCredentials];
          self->authentication_ = nil;
        }
        case OrgSpongycastleCryptoTlsTlsProtocol_CS_SERVER_CERTIFICATE:
        case OrgSpongycastleCryptoTlsTlsProtocol_CS_CERTIFICATE_STATUS:
        {
          [((id<OrgSpongycastleCryptoTlsTlsKeyExchange>) nil_chk(self->keyExchange_)) processServerKeyExchangeWithJavaIoInputStream:buf];
          OrgSpongycastleCryptoTlsTlsProtocol_assertEmptyWithJavaIoByteArrayInputStream_(buf);
          break;
        }
        default:
        @throw new_OrgSpongycastleCryptoTlsTlsFatalAlert_initWithShort_(OrgSpongycastleCryptoTlsAlertDescription_unexpected_message);
      }
      self->connection_state_ = OrgSpongycastleCryptoTlsTlsProtocol_CS_SERVER_KEY_EXCHANGE;
      break;
    }
    case OrgSpongycastleCryptoTlsHandshakeType_certificate_request:
    {
      switch (self->connection_state_) {
        case OrgSpongycastleCryptoTlsTlsProtocol_CS_SERVER_CERTIFICATE:
        case OrgSpongycastleCryptoTlsTlsProtocol_CS_CERTIFICATE_STATUS:
        {
          [((id<OrgSpongycastleCryptoTlsTlsKeyExchange>) nil_chk(self->keyExchange_)) skipServerKeyExchange];
        }
        case OrgSpongycastleCryptoTlsTlsProtocol_CS_SERVER_KEY_EXCHANGE:
        {
          if (self->authentication_ == nil) {
            @throw new_OrgSpongycastleCryptoTlsTlsFatalAlert_initWithShort_(OrgSpongycastleCryptoTlsAlertDescription_handshake_failure);
          }
          self->certificateRequest_ = OrgSpongycastleCryptoTlsCertificateRequest_parseWithOrgSpongycastleCryptoTlsTlsContext_withJavaIoInputStream_([self getContext], buf);
          OrgSpongycastleCryptoTlsTlsProtocol_assertEmptyWithJavaIoByteArrayInputStream_(buf);
          [((id<OrgSpongycastleCryptoTlsTlsKeyExchange>) nil_chk(self->keyExchange_)) validateCertificateRequestWithOrgSpongycastleCryptoTlsCertificateRequest:self->certificateRequest_];
          OrgSpongycastleCryptoTlsTlsUtils_trackHashAlgorithmsWithOrgSpongycastleCryptoTlsTlsHandshakeHash_withJavaUtilVector_([((OrgSpongycastleCryptoTlsRecordStream *) nil_chk(self->recordStream_)) getHandshakeHash], [((OrgSpongycastleCryptoTlsCertificateRequest *) nil_chk(self->certificateRequest_)) getSupportedSignatureAlgorithms]);
          break;
        }
        default:
        @throw new_OrgSpongycastleCryptoTlsTlsFatalAlert_initWithShort_(OrgSpongycastleCryptoTlsAlertDescription_unexpected_message);
      }
      self->connection_state_ = OrgSpongycastleCryptoTlsTlsProtocol_CS_CERTIFICATE_REQUEST;
      break;
    }
    case OrgSpongycastleCryptoTlsHandshakeType_session_ticket:
    {
      switch (self->connection_state_) {
        case OrgSpongycastleCryptoTlsTlsProtocol_CS_CLIENT_FINISHED:
        {
          if (!self->expectSessionTicket_) {
            @throw new_OrgSpongycastleCryptoTlsTlsFatalAlert_initWithShort_(OrgSpongycastleCryptoTlsAlertDescription_unexpected_message);
          }
          [self invalidateSession];
          [self receiveNewSessionTicketMessageWithJavaIoByteArrayInputStream:buf];
          break;
        }
        default:
        @throw new_OrgSpongycastleCryptoTlsTlsFatalAlert_initWithShort_(OrgSpongycastleCryptoTlsAlertDescription_unexpected_message);
      }
      self->connection_state_ = OrgSpongycastleCryptoTlsTlsProtocol_CS_SERVER_SESSION_TICKET;
      break;
    }
    case OrgSpongycastleCryptoTlsHandshakeType_hello_request:
    {
      OrgSpongycastleCryptoTlsTlsProtocol_assertEmptyWithJavaIoByteArrayInputStream_(buf);
      if (self->connection_state_ == OrgSpongycastleCryptoTlsTlsProtocol_CS_END) {
        [self refuseRenegotiation];
      }
      break;
    }
    case OrgSpongycastleCryptoTlsHandshakeType_client_hello:
    case OrgSpongycastleCryptoTlsHandshakeType_client_key_exchange:
    case OrgSpongycastleCryptoTlsHandshakeType_certificate_verify:
    case OrgSpongycastleCryptoTlsHandshakeType_hello_verify_request:
    default:
    @throw new_OrgSpongycastleCryptoTlsTlsFatalAlert_initWithShort_(OrgSpongycastleCryptoTlsAlertDescription_unexpected_message);
  }
}

- (void)handleSupplementalDataWithJavaUtilVector:(JavaUtilVector *)serverSupplementalData {
  [((id<OrgSpongycastleCryptoTlsTlsClient>) nil_chk(self->tlsClient_)) processServerSupplementalDataWithJavaUtilVector:serverSupplementalData];
  self->connection_state_ = OrgSpongycastleCryptoTlsTlsProtocol_CS_SERVER_SUPPLEMENTAL_DATA;
  self->keyExchange_ = [((id<OrgSpongycastleCryptoTlsTlsClient>) nil_chk(tlsClient_)) getKeyExchange];
  [((id<OrgSpongycastleCryptoTlsTlsKeyExchange>) nil_chk(self->keyExchange_)) init__WithOrgSpongycastleCryptoTlsTlsContext:[self getContext]];
}

- (void)receiveNewSessionTicketMessageWithJavaIoByteArrayInputStream:(JavaIoByteArrayInputStream *)buf {
  OrgSpongycastleCryptoTlsNewSessionTicket *newSessionTicket = OrgSpongycastleCryptoTlsNewSessionTicket_parseWithJavaIoInputStream_(buf);
  OrgSpongycastleCryptoTlsTlsProtocol_assertEmptyWithJavaIoByteArrayInputStream_(buf);
  [((id<OrgSpongycastleCryptoTlsTlsClient>) nil_chk(tlsClient_)) notifyNewSessionTicketWithOrgSpongycastleCryptoTlsNewSessionTicket:newSessionTicket];
}

- (void)receiveServerHelloMessageWithJavaIoByteArrayInputStream:(JavaIoByteArrayInputStream *)buf {
  {
    OrgSpongycastleCryptoTlsProtocolVersion *server_version = OrgSpongycastleCryptoTlsTlsUtils_readVersionWithJavaIoInputStream_(buf);
    if ([((OrgSpongycastleCryptoTlsProtocolVersion *) nil_chk(server_version)) isDTLS]) {
      @throw new_OrgSpongycastleCryptoTlsTlsFatalAlert_initWithShort_(OrgSpongycastleCryptoTlsAlertDescription_illegal_parameter);
    }
    if (![server_version equalsWithOrgSpongycastleCryptoTlsProtocolVersion:[((OrgSpongycastleCryptoTlsRecordStream *) nil_chk(self->recordStream_)) getReadVersion]]) {
      @throw new_OrgSpongycastleCryptoTlsTlsFatalAlert_initWithShort_(OrgSpongycastleCryptoTlsAlertDescription_illegal_parameter);
    }
    OrgSpongycastleCryptoTlsProtocolVersion *client_version = [((id<OrgSpongycastleCryptoTlsTlsContext>) nil_chk([self getContext])) getClientVersion];
    if (![server_version isEqualOrEarlierVersionOfWithOrgSpongycastleCryptoTlsProtocolVersion:client_version]) {
      @throw new_OrgSpongycastleCryptoTlsTlsFatalAlert_initWithShort_(OrgSpongycastleCryptoTlsAlertDescription_illegal_parameter);
    }
    [((OrgSpongycastleCryptoTlsRecordStream *) nil_chk(self->recordStream_)) setWriteVersionWithOrgSpongycastleCryptoTlsProtocolVersion:server_version];
    [((OrgSpongycastleCryptoTlsAbstractTlsContext *) nil_chk([self getContextAdmin])) setServerVersionWithOrgSpongycastleCryptoTlsProtocolVersion:server_version];
    [((id<OrgSpongycastleCryptoTlsTlsClient>) nil_chk(self->tlsClient_)) notifyServerVersionWithOrgSpongycastleCryptoTlsProtocolVersion:server_version];
  }
  ((OrgSpongycastleCryptoTlsSecurityParameters *) nil_chk(self->securityParameters_))->serverRandom_ = OrgSpongycastleCryptoTlsTlsUtils_readFullyWithInt_withJavaIoInputStream_(32, buf);
  self->selectedSessionID_ = OrgSpongycastleCryptoTlsTlsUtils_readOpaque8WithJavaIoInputStream_(buf);
  if (((IOSByteArray *) nil_chk(self->selectedSessionID_))->size_ > 32) {
    @throw new_OrgSpongycastleCryptoTlsTlsFatalAlert_initWithShort_(OrgSpongycastleCryptoTlsAlertDescription_illegal_parameter);
  }
  [((id<OrgSpongycastleCryptoTlsTlsClient>) nil_chk(self->tlsClient_)) notifySessionIDWithByteArray:self->selectedSessionID_];
  self->resumedSession_ = (((IOSByteArray *) nil_chk(self->selectedSessionID_))->size_ > 0 && self->tlsSession_ != nil && OrgSpongycastleUtilArrays_areEqualWithByteArray_withByteArray_(self->selectedSessionID_, [self->tlsSession_ getSessionID]));
  jint selectedCipherSuite = OrgSpongycastleCryptoTlsTlsUtils_readUint16WithJavaIoInputStream_(buf);
  if (!OrgSpongycastleUtilArrays_containsWithIntArray_withInt_(self->offeredCipherSuites_, selectedCipherSuite) || selectedCipherSuite == OrgSpongycastleCryptoTlsCipherSuite_TLS_NULL_WITH_NULL_NULL || OrgSpongycastleCryptoTlsCipherSuite_isSCSVWithInt_(selectedCipherSuite) || !OrgSpongycastleCryptoTlsTlsUtils_isValidCipherSuiteForVersionWithInt_withOrgSpongycastleCryptoTlsProtocolVersion_(selectedCipherSuite, [((id<OrgSpongycastleCryptoTlsTlsContext>) nil_chk([self getContext])) getServerVersion])) {
    @throw new_OrgSpongycastleCryptoTlsTlsFatalAlert_initWithShort_(OrgSpongycastleCryptoTlsAlertDescription_illegal_parameter);
  }
  [((id<OrgSpongycastleCryptoTlsTlsClient>) nil_chk(self->tlsClient_)) notifySelectedCipherSuiteWithInt:selectedCipherSuite];
  jshort selectedCompressionMethod = OrgSpongycastleCryptoTlsTlsUtils_readUint8WithJavaIoInputStream_(buf);
  if (!OrgSpongycastleUtilArrays_containsWithShortArray_withShort_(self->offeredCompressionMethods_, selectedCompressionMethod)) {
    @throw new_OrgSpongycastleCryptoTlsTlsFatalAlert_initWithShort_(OrgSpongycastleCryptoTlsAlertDescription_illegal_parameter);
  }
  [((id<OrgSpongycastleCryptoTlsTlsClient>) nil_chk(self->tlsClient_)) notifySelectedCompressionMethodWithShort:selectedCompressionMethod];
  self->serverExtensions_ = OrgSpongycastleCryptoTlsTlsProtocol_readExtensionsWithJavaIoByteArrayInputStream_(buf);
  if (self->serverExtensions_ != nil) {
    id<JavaUtilEnumeration> e = [self->serverExtensions_ keys];
    while ([((id<JavaUtilEnumeration>) nil_chk(e)) hasMoreElements]) {
      JavaLangInteger *extType = (JavaLangInteger *) cast_chk([e nextElement], [JavaLangInteger class]);
      if ([((JavaLangInteger *) nil_chk(extType)) isEqual:JreLoadStatic(OrgSpongycastleCryptoTlsTlsProtocol, EXT_RenegotiationInfo)]) {
        continue;
      }
      if (nil == OrgSpongycastleCryptoTlsTlsUtils_getExtensionDataWithJavaUtilHashtable_withJavaLangInteger_(self->clientExtensions_, extType)) {
        @throw new_OrgSpongycastleCryptoTlsTlsFatalAlert_initWithShort_(OrgSpongycastleCryptoTlsAlertDescription_unsupported_extension);
      }
      if (self->resumedSession_) {
      }
    }
  }
  {
    IOSByteArray *renegExtData = OrgSpongycastleCryptoTlsTlsUtils_getExtensionDataWithJavaUtilHashtable_withJavaLangInteger_(self->serverExtensions_, JreLoadStatic(OrgSpongycastleCryptoTlsTlsProtocol, EXT_RenegotiationInfo));
    if (renegExtData != nil) {
      self->secure_renegotiation_ = true;
      if (!OrgSpongycastleUtilArrays_constantTimeAreEqualWithByteArray_withByteArray_(renegExtData, OrgSpongycastleCryptoTlsTlsProtocol_createRenegotiationInfoWithByteArray_(JreLoadStatic(OrgSpongycastleCryptoTlsTlsUtils, EMPTY_BYTES)))) {
        @throw new_OrgSpongycastleCryptoTlsTlsFatalAlert_initWithShort_(OrgSpongycastleCryptoTlsAlertDescription_handshake_failure);
      }
    }
  }
  [((id<OrgSpongycastleCryptoTlsTlsClient>) nil_chk(self->tlsClient_)) notifySecureRenegotiationWithBoolean:self->secure_renegotiation_];
  JavaUtilHashtable *sessionClientExtensions = clientExtensions_;
  JavaUtilHashtable *sessionServerExtensions = serverExtensions_;
  if (self->resumedSession_) {
    if (selectedCipherSuite != [((OrgSpongycastleCryptoTlsSessionParameters *) nil_chk(self->sessionParameters_)) getCipherSuite] || selectedCompressionMethod != [((OrgSpongycastleCryptoTlsSessionParameters *) nil_chk(self->sessionParameters_)) getCompressionAlgorithm]) {
      @throw new_OrgSpongycastleCryptoTlsTlsFatalAlert_initWithShort_(OrgSpongycastleCryptoTlsAlertDescription_illegal_parameter);
    }
    sessionClientExtensions = nil;
    sessionServerExtensions = [((OrgSpongycastleCryptoTlsSessionParameters *) nil_chk(self->sessionParameters_)) readServerExtensions];
  }
  ((OrgSpongycastleCryptoTlsSecurityParameters *) nil_chk(self->securityParameters_))->cipherSuite_ = selectedCipherSuite;
  self->securityParameters_->compressionAlgorithm_ = selectedCompressionMethod;
  if (sessionServerExtensions != nil) {
    {
      jboolean serverSentEncryptThenMAC = OrgSpongycastleCryptoTlsTlsExtensionsUtils_hasEncryptThenMACExtensionWithJavaUtilHashtable_(sessionServerExtensions);
      if (serverSentEncryptThenMAC && !OrgSpongycastleCryptoTlsTlsUtils_isBlockCipherSuiteWithInt_(selectedCipherSuite)) {
        @throw new_OrgSpongycastleCryptoTlsTlsFatalAlert_initWithShort_(OrgSpongycastleCryptoTlsAlertDescription_illegal_parameter);
      }
      ((OrgSpongycastleCryptoTlsSecurityParameters *) nil_chk(self->securityParameters_))->encryptThenMAC_ = serverSentEncryptThenMAC;
    }
    self->securityParameters_->extendedMasterSecret_ = OrgSpongycastleCryptoTlsTlsExtensionsUtils_hasExtendedMasterSecretExtensionWithJavaUtilHashtable_(sessionServerExtensions);
    ((OrgSpongycastleCryptoTlsSecurityParameters *) nil_chk(self->securityParameters_))->maxFragmentLength_ = [self processMaxFragmentLengthExtensionWithJavaUtilHashtable:sessionClientExtensions withJavaUtilHashtable:sessionServerExtensions withShort:OrgSpongycastleCryptoTlsAlertDescription_illegal_parameter];
    ((OrgSpongycastleCryptoTlsSecurityParameters *) nil_chk(self->securityParameters_))->truncatedHMac_ = OrgSpongycastleCryptoTlsTlsExtensionsUtils_hasTruncatedHMacExtensionWithJavaUtilHashtable_(sessionServerExtensions);
    self->allowCertificateStatus_ = (!self->resumedSession_ && OrgSpongycastleCryptoTlsTlsUtils_hasExpectedEmptyExtensionDataWithJavaUtilHashtable_withJavaLangInteger_withShort_(sessionServerExtensions, JreLoadStatic(OrgSpongycastleCryptoTlsTlsExtensionsUtils, EXT_status_request), OrgSpongycastleCryptoTlsAlertDescription_illegal_parameter));
    self->expectSessionTicket_ = (!self->resumedSession_ && OrgSpongycastleCryptoTlsTlsUtils_hasExpectedEmptyExtensionDataWithJavaUtilHashtable_withJavaLangInteger_withShort_(sessionServerExtensions, JreLoadStatic(OrgSpongycastleCryptoTlsTlsProtocol, EXT_SessionTicket), OrgSpongycastleCryptoTlsAlertDescription_illegal_parameter));
  }
  if (sessionClientExtensions != nil) {
    [((id<OrgSpongycastleCryptoTlsTlsClient>) nil_chk(self->tlsClient_)) processServerExtensionsWithJavaUtilHashtable:sessionServerExtensions];
  }
  ((OrgSpongycastleCryptoTlsSecurityParameters *) nil_chk(self->securityParameters_))->prfAlgorithm_ = OrgSpongycastleCryptoTlsTlsProtocol_getPRFAlgorithmWithOrgSpongycastleCryptoTlsTlsContext_withInt_([self getContext], [((OrgSpongycastleCryptoTlsSecurityParameters *) nil_chk(self->securityParameters_)) getCipherSuite]);
  ((OrgSpongycastleCryptoTlsSecurityParameters *) nil_chk(self->securityParameters_))->verifyDataLength_ = 12;
}

- (void)sendCertificateVerifyMessageWithOrgSpongycastleCryptoTlsDigitallySigned:(OrgSpongycastleCryptoTlsDigitallySigned *)certificateVerify {
  OrgSpongycastleCryptoTlsTlsProtocol_HandshakeMessage *message = new_OrgSpongycastleCryptoTlsTlsProtocol_HandshakeMessage_initWithOrgSpongycastleCryptoTlsTlsProtocol_withShort_(self, OrgSpongycastleCryptoTlsHandshakeType_certificate_verify);
  [((OrgSpongycastleCryptoTlsDigitallySigned *) nil_chk(certificateVerify)) encodeWithJavaIoOutputStream:message];
  [message writeToRecordStream];
}

- (void)sendClientHelloMessage {
  [((OrgSpongycastleCryptoTlsRecordStream *) nil_chk(self->recordStream_)) setWriteVersionWithOrgSpongycastleCryptoTlsProtocolVersion:[((id<OrgSpongycastleCryptoTlsTlsClient>) nil_chk(self->tlsClient_)) getClientHelloRecordLayerVersion]];
  OrgSpongycastleCryptoTlsProtocolVersion *client_version = [((id<OrgSpongycastleCryptoTlsTlsClient>) nil_chk(self->tlsClient_)) getClientVersion];
  if ([((OrgSpongycastleCryptoTlsProtocolVersion *) nil_chk(client_version)) isDTLS]) {
    @throw new_OrgSpongycastleCryptoTlsTlsFatalAlert_initWithShort_(OrgSpongycastleCryptoTlsAlertDescription_internal_error);
  }
  [((OrgSpongycastleCryptoTlsAbstractTlsContext *) nil_chk([self getContextAdmin])) setClientVersionWithOrgSpongycastleCryptoTlsProtocolVersion:client_version];
  IOSByteArray *session_id = JreLoadStatic(OrgSpongycastleCryptoTlsTlsUtils, EMPTY_BYTES);
  if (self->tlsSession_ != nil) {
    session_id = [self->tlsSession_ getSessionID];
    if (session_id == nil || session_id->size_ > 32) {
      session_id = JreLoadStatic(OrgSpongycastleCryptoTlsTlsUtils, EMPTY_BYTES);
    }
  }
  jboolean fallback = [((id<OrgSpongycastleCryptoTlsTlsClient>) nil_chk(self->tlsClient_)) isFallback];
  self->offeredCipherSuites_ = [((id<OrgSpongycastleCryptoTlsTlsClient>) nil_chk(self->tlsClient_)) getCipherSuites];
  self->offeredCompressionMethods_ = [((id<OrgSpongycastleCryptoTlsTlsClient>) nil_chk(self->tlsClient_)) getCompressionMethods];
  if (((IOSByteArray *) nil_chk(session_id))->size_ > 0 && self->sessionParameters_ != nil) {
    if (!OrgSpongycastleUtilArrays_containsWithIntArray_withInt_(self->offeredCipherSuites_, [sessionParameters_ getCipherSuite]) || !OrgSpongycastleUtilArrays_containsWithShortArray_withShort_(self->offeredCompressionMethods_, [((OrgSpongycastleCryptoTlsSessionParameters *) nil_chk(sessionParameters_)) getCompressionAlgorithm])) {
      session_id = JreLoadStatic(OrgSpongycastleCryptoTlsTlsUtils, EMPTY_BYTES);
    }
  }
  self->clientExtensions_ = [((id<OrgSpongycastleCryptoTlsTlsClient>) nil_chk(self->tlsClient_)) getClientExtensions];
  OrgSpongycastleCryptoTlsTlsProtocol_HandshakeMessage *message = new_OrgSpongycastleCryptoTlsTlsProtocol_HandshakeMessage_initWithOrgSpongycastleCryptoTlsTlsProtocol_withShort_(self, OrgSpongycastleCryptoTlsHandshakeType_client_hello);
  OrgSpongycastleCryptoTlsTlsUtils_writeVersionWithOrgSpongycastleCryptoTlsProtocolVersion_withJavaIoOutputStream_(client_version, message);
  [message writeWithByteArray:[((OrgSpongycastleCryptoTlsSecurityParameters *) nil_chk(self->securityParameters_)) getClientRandom]];
  OrgSpongycastleCryptoTlsTlsUtils_writeOpaque8WithByteArray_withJavaIoOutputStream_(session_id, message);
  {
    IOSByteArray *renegExtData = OrgSpongycastleCryptoTlsTlsUtils_getExtensionDataWithJavaUtilHashtable_withJavaLangInteger_(clientExtensions_, JreLoadStatic(OrgSpongycastleCryptoTlsTlsProtocol, EXT_RenegotiationInfo));
    jboolean noRenegExt = nil == renegExtData;
    jboolean noRenegSCSV = !OrgSpongycastleUtilArrays_containsWithIntArray_withInt_(offeredCipherSuites_, OrgSpongycastleCryptoTlsCipherSuite_TLS_EMPTY_RENEGOTIATION_INFO_SCSV);
    if (noRenegExt && noRenegSCSV) {
      self->offeredCipherSuites_ = OrgSpongycastleUtilArrays_appendWithIntArray_withInt_(offeredCipherSuites_, OrgSpongycastleCryptoTlsCipherSuite_TLS_EMPTY_RENEGOTIATION_INFO_SCSV);
    }
    if (fallback && !OrgSpongycastleUtilArrays_containsWithIntArray_withInt_(offeredCipherSuites_, OrgSpongycastleCryptoTlsCipherSuite_TLS_FALLBACK_SCSV)) {
      self->offeredCipherSuites_ = OrgSpongycastleUtilArrays_appendWithIntArray_withInt_(offeredCipherSuites_, OrgSpongycastleCryptoTlsCipherSuite_TLS_FALLBACK_SCSV);
    }
    OrgSpongycastleCryptoTlsTlsUtils_writeUint16ArrayWithUint16LengthWithIntArray_withJavaIoOutputStream_(offeredCipherSuites_, message);
  }
  OrgSpongycastleCryptoTlsTlsUtils_writeUint8ArrayWithUint8LengthWithShortArray_withJavaIoOutputStream_(offeredCompressionMethods_, message);
  if (clientExtensions_ != nil) {
    OrgSpongycastleCryptoTlsTlsProtocol_writeExtensionsWithJavaIoOutputStream_withJavaUtilHashtable_(message, clientExtensions_);
  }
  [message writeToRecordStream];
}

- (void)sendClientKeyExchangeMessage {
  OrgSpongycastleCryptoTlsTlsProtocol_HandshakeMessage *message = new_OrgSpongycastleCryptoTlsTlsProtocol_HandshakeMessage_initWithOrgSpongycastleCryptoTlsTlsProtocol_withShort_(self, OrgSpongycastleCryptoTlsHandshakeType_client_key_exchange);
  [((id<OrgSpongycastleCryptoTlsTlsKeyExchange>) nil_chk(self->keyExchange_)) generateClientKeyExchangeWithJavaIoOutputStream:message];
  [message writeToRecordStream];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 2, 3, 4, -1, -1, -1 },
    { NULL, "V", 0x4, -1, -1, -1, -1, -1, -1 },
    { NULL, "LOrgSpongycastleCryptoTlsTlsContext;", 0x4, -1, -1, -1, -1, -1, -1 },
    { NULL, "LOrgSpongycastleCryptoTlsAbstractTlsContext;", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "LOrgSpongycastleCryptoTlsTlsPeer;", 0x4, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x4, 5, 6, 4, -1, -1, -1 },
    { NULL, "V", 0x4, 7, 8, 4, -1, -1, -1 },
    { NULL, "V", 0x4, 9, 10, 4, -1, -1, -1 },
    { NULL, "V", 0x4, 11, 10, 4, -1, -1, -1 },
    { NULL, "V", 0x4, 12, 13, 4, -1, -1, -1 },
    { NULL, "V", 0x4, -1, -1, 4, -1, -1, -1 },
    { NULL, "V", 0x4, -1, -1, 4, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithJavaIoInputStream:withJavaIoOutputStream:withJavaSecuritySecureRandom:);
  methods[1].selector = @selector(initWithJavaSecuritySecureRandom:);
  methods[2].selector = @selector(connectWithOrgSpongycastleCryptoTlsTlsClient:);
  methods[3].selector = @selector(cleanupHandshake);
  methods[4].selector = @selector(getContext);
  methods[5].selector = @selector(getContextAdmin);
  methods[6].selector = @selector(getPeer);
  methods[7].selector = @selector(handleHandshakeMessageWithShort:withJavaIoByteArrayInputStream:);
  methods[8].selector = @selector(handleSupplementalDataWithJavaUtilVector:);
  methods[9].selector = @selector(receiveNewSessionTicketMessageWithJavaIoByteArrayInputStream:);
  methods[10].selector = @selector(receiveServerHelloMessageWithJavaIoByteArrayInputStream:);
  methods[11].selector = @selector(sendCertificateVerifyMessageWithOrgSpongycastleCryptoTlsDigitallySigned:);
  methods[12].selector = @selector(sendClientHelloMessage);
  methods[13].selector = @selector(sendClientKeyExchangeMessage);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "tlsClient_", "LOrgSpongycastleCryptoTlsTlsClient;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "tlsClientContext_", "LOrgSpongycastleCryptoTlsTlsClientContextImpl;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "selectedSessionID_", "[B", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "keyExchange_", "LOrgSpongycastleCryptoTlsTlsKeyExchange;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "authentication_", "LOrgSpongycastleCryptoTlsTlsAuthentication;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "certificateStatus_", "LOrgSpongycastleCryptoTlsCertificateStatus;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "certificateRequest_", "LOrgSpongycastleCryptoTlsCertificateRequest;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LJavaIoInputStream;LJavaIoOutputStream;LJavaSecuritySecureRandom;", "LJavaSecuritySecureRandom;", "connect", "LOrgSpongycastleCryptoTlsTlsClient;", "LJavaIoIOException;", "handleHandshakeMessage", "SLJavaIoByteArrayInputStream;", "handleSupplementalData", "LJavaUtilVector;", "receiveNewSessionTicketMessage", "LJavaIoByteArrayInputStream;", "receiveServerHelloMessage", "sendCertificateVerifyMessage", "LOrgSpongycastleCryptoTlsDigitallySigned;" };
  static const J2ObjcClassInfo _OrgSpongycastleCryptoTlsTlsClientProtocol = { "TlsClientProtocol", "org.spongycastle.crypto.tls", ptrTable, methods, fields, 7, 0x1, 14, 7, -1, -1, -1, -1, -1 };
  return &_OrgSpongycastleCryptoTlsTlsClientProtocol;
}

@end

void OrgSpongycastleCryptoTlsTlsClientProtocol_initWithJavaIoInputStream_withJavaIoOutputStream_withJavaSecuritySecureRandom_(OrgSpongycastleCryptoTlsTlsClientProtocol *self, JavaIoInputStream *input, JavaIoOutputStream *output, JavaSecuritySecureRandom *secureRandom) {
  OrgSpongycastleCryptoTlsTlsProtocol_initWithJavaIoInputStream_withJavaIoOutputStream_withJavaSecuritySecureRandom_(self, input, output, secureRandom);
  self->tlsClient_ = nil;
  self->tlsClientContext_ = nil;
  self->selectedSessionID_ = nil;
  self->keyExchange_ = nil;
  self->authentication_ = nil;
  self->certificateStatus_ = nil;
  self->certificateRequest_ = nil;
}

OrgSpongycastleCryptoTlsTlsClientProtocol *new_OrgSpongycastleCryptoTlsTlsClientProtocol_initWithJavaIoInputStream_withJavaIoOutputStream_withJavaSecuritySecureRandom_(JavaIoInputStream *input, JavaIoOutputStream *output, JavaSecuritySecureRandom *secureRandom) {
  J2OBJC_NEW_IMPL(OrgSpongycastleCryptoTlsTlsClientProtocol, initWithJavaIoInputStream_withJavaIoOutputStream_withJavaSecuritySecureRandom_, input, output, secureRandom)
}

OrgSpongycastleCryptoTlsTlsClientProtocol *create_OrgSpongycastleCryptoTlsTlsClientProtocol_initWithJavaIoInputStream_withJavaIoOutputStream_withJavaSecuritySecureRandom_(JavaIoInputStream *input, JavaIoOutputStream *output, JavaSecuritySecureRandom *secureRandom) {
  J2OBJC_CREATE_IMPL(OrgSpongycastleCryptoTlsTlsClientProtocol, initWithJavaIoInputStream_withJavaIoOutputStream_withJavaSecuritySecureRandom_, input, output, secureRandom)
}

void OrgSpongycastleCryptoTlsTlsClientProtocol_initWithJavaSecuritySecureRandom_(OrgSpongycastleCryptoTlsTlsClientProtocol *self, JavaSecuritySecureRandom *secureRandom) {
  OrgSpongycastleCryptoTlsTlsProtocol_initWithJavaSecuritySecureRandom_(self, secureRandom);
  self->tlsClient_ = nil;
  self->tlsClientContext_ = nil;
  self->selectedSessionID_ = nil;
  self->keyExchange_ = nil;
  self->authentication_ = nil;
  self->certificateStatus_ = nil;
  self->certificateRequest_ = nil;
}

OrgSpongycastleCryptoTlsTlsClientProtocol *new_OrgSpongycastleCryptoTlsTlsClientProtocol_initWithJavaSecuritySecureRandom_(JavaSecuritySecureRandom *secureRandom) {
  J2OBJC_NEW_IMPL(OrgSpongycastleCryptoTlsTlsClientProtocol, initWithJavaSecuritySecureRandom_, secureRandom)
}

OrgSpongycastleCryptoTlsTlsClientProtocol *create_OrgSpongycastleCryptoTlsTlsClientProtocol_initWithJavaSecuritySecureRandom_(JavaSecuritySecureRandom *secureRandom) {
  J2OBJC_CREATE_IMPL(OrgSpongycastleCryptoTlsTlsClientProtocol, initWithJavaSecuritySecureRandom_, secureRandom)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(OrgSpongycastleCryptoTlsTlsClientProtocol)
